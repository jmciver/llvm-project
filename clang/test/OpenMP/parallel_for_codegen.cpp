// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature --include-generated-funcs --replace-value-regex "__omp_offloading_[0-9a-z]+_[0-9a-z]+" "reduction_size[.].+[.]" "pl_cond[.].+[.|,]" --prefix-filecheck-ir-name _
// RUN: %clang_cc1 -verify -Wno-vla -fopenmp -x c++ -triple x86_64-unknown-unknown -emit-llvm %s -fexceptions -fcxx-exceptions -o - | FileCheck %s --check-prefix=CHECK1
// RUN: %clang_cc1 -verify -Wno-vla -fopenmp -fopenmp-version=45 -x c++ -triple x86_64-unknown-unknown -emit-llvm %s -fexceptions -fcxx-exceptions -o - | FileCheck %s --check-prefix=CHECK2

// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -triple x86_64-unknown-unknown -fexceptions -fcxx-exceptions -emit-pch -o %t %s
// RUN: %clang_cc1 -fopenmp -x c++ -triple x86_64-unknown-unknown -fexceptions -fcxx-exceptions -std=c++11 -include-pch %t -verify -Wno-vla %s -emit-llvm -o - | FileCheck %s --check-prefix=CHECK1

// RUN: %clang_cc1 -fopenmp -fopenmp-version=45 -x c++ -std=c++11 -triple x86_64-unknown-unknown -fexceptions -fcxx-exceptions -emit-pch -o %t %s
// RUN: %clang_cc1 -fopenmp -fopenmp-version=45 -x c++ -triple x86_64-unknown-unknown -fexceptions -fcxx-exceptions -std=c++11 -include-pch %t -verify -Wno-vla %s -emit-llvm -o - | FileCheck %s --check-prefix=CHECK2

// RUN: %clang_cc1 -verify -Wno-vla -triple x86_64-apple-darwin10 -fopenmp -fexceptions -fcxx-exceptions -debug-info-kind=line-tables-only -gno-column-info -x c++ -emit-llvm %s -o - | FileCheck %s --check-prefix=CHECK5
// RUN: %clang_cc1 -verify -Wno-vla -triple x86_64-apple-darwin10 -fopenmp -emit-llvm %s -o - | FileCheck %s --check-prefix=CHECK6

// RUN: %clang_cc1 -verify -Wno-vla -fopenmp-simd -x c++ -triple x86_64-unknown-unknown -emit-llvm %s -fexceptions -fcxx-exceptions -o - | FileCheck %s --implicit-check-not="{{__kmpc|__tgt}}"
// RUN: %clang_cc1 -fopenmp-simd -x c++ -std=c++11 -triple x86_64-unknown-unknown -fexceptions -fcxx-exceptions -emit-pch -o %t %s
// RUN: %clang_cc1 -fopenmp-simd -x c++ -triple x86_64-unknown-unknown -fexceptions -fcxx-exceptions -std=c++11 -include-pch %t -verify -Wno-vla %s -emit-llvm -o - | FileCheck %s --implicit-check-not="{{__kmpc|__tgt}}"
// RUN: %clang_cc1 -verify -Wno-vla -triple x86_64-apple-darwin10 -fopenmp-simd -fexceptions -fcxx-exceptions -debug-info-kind=line-tables-only -x c++ -emit-llvm %s -o - | FileCheck %s --implicit-check-not="{{__kmpc|__tgt}}"
// RUN: %clang_cc1 -verify -Wno-vla -triple x86_64-apple-darwin10 -fopenmp-simd -emit-llvm %s -o - | FileCheck %s --implicit-check-not="{{__kmpc|__tgt}}"
// expected-no-diagnostics

// RUN: %clang_cc1 -verify -Wno-vla -fopenmp -DOMP5 -x c++ -triple x86_64-unknown-unknown -emit-llvm %s -fexceptions -fcxx-exceptions -o - | FileCheck %s --check-prefix=CHECK11
// RUN: %clang_cc1 -fopenmp -DOMP5 -x c++ -std=c++11 -triple x86_64-unknown-unknown -fexceptions -fcxx-exceptions -emit-pch -o %t %s
// RUN: %clang_cc1 -fopenmp -DOMP5 -x c++ -triple x86_64-unknown-unknown -fexceptions -fcxx-exceptions -std=c++11 -include-pch %t -verify -Wno-vla %s -emit-llvm -o - | FileCheck %s --check-prefix=CHECK11
// RUN: %clang_cc1 -verify -Wno-vla -fopenmp-simd -DOMP5 -x c++ -triple x86_64-unknown-unknown -emit-llvm %s -fexceptions -fcxx-exceptions -o - | FileCheck %s --implicit-check-not="{{__kmpc|__tgt}}"
// RUN: %clang_cc1 -fopenmp-simd -DOMP5 -x c++ -std=c++11 -triple x86_64-unknown-unknown -fexceptions -fcxx-exceptions -emit-pch -o %t %s
// RUN: %clang_cc1 -fopenmp-simd -DOMP5 -x c++ -triple x86_64-unknown-unknown -fexceptions -fcxx-exceptions -std=c++11 -include-pch %t -verify -Wno-vla %s -emit-llvm -o - | FileCheck %s --implicit-check-not="{{__kmpc|__tgt}}"
#ifndef HEADER
#define HEADER

#ifndef OMP5

void with_var_schedule() {
  double a = 5;

#pragma omp parallel for schedule(static, char(a)) private(a)
  for (unsigned long long i = 1; i < 2 + a; ++i) {
  }
}

void without_schedule_clause(float *a, float *b, float *c, float *d) {
  #pragma omp parallel for
// UB = min(UB, GlobalUB)
// Loop header
  for (int i = 33; i < 32000000; i += 7) {
// Start of body: calculate i from IV:
// ... loop body ...
// End of body: store into a[i]:
    a[i] = b[i] * c[i] * d[i];
  }
}

void static_not_chunked(float *a, float *b, float *c, float *d) {
  #pragma omp parallel for schedule(static)
// UB = min(UB, GlobalUB)
// Loop header
  for (int i = 32000000; i > 33; i += -7) {
// Start of body: calculate i from IV:
// ... loop body ...
// End of body: store into a[i]:
    a[i] = b[i] * c[i] * d[i];
  }
}

void static_chunked(float *a, float *b, float *c, float *d) {
  #pragma omp parallel for schedule(static, 5)
// UB = min(UB, GlobalUB)

// Outer loop header

// Loop header
  for (unsigned i = 131071; i <= 2147483647; i += 127) {
// Start of body: calculate i from IV:
// ... loop body ...
// End of body: store into a[i]:
    a[i] = b[i] * c[i] * d[i];
  }
// Update the counters, adding stride

}

void dynamic1(float *a, float *b, float *c, float *d) {
  #pragma omp parallel for schedule(dynamic)

// Loop header

  for (unsigned long long i = 131071; i < 2147483647; i += 127) {
// Start of body: calculate i from IV:
// ... loop body ...
// End of body: store into a[i]:
    a[i] = b[i] * c[i] * d[i];
  }
}

void guided7(float *a, float *b, float *c, float *d) {
  #pragma omp parallel for schedule(guided, 7)

// Loop header

  for (unsigned long long i = 131071; i < 2147483647; i += 127) {
// Start of body: calculate i from IV:
// ... loop body ...
// End of body: store into a[i]:
    a[i] = b[i] * c[i] * d[i];
  }
}

void test_auto(float *a, float *b, float *c, float *d) {
  unsigned int x = 0;
  unsigned int y = 0;
  #pragma omp parallel for schedule(auto) collapse(2)

// Loop header

// FIXME: When the iteration count of some nested loop is not a known constant,
// we should pre-calculate it, like we do for the total number of iterations!
  for (char i = static_cast<char>(y); i <= '9'; ++i)
    for (x = 11; x > 0; --x) {
// Start of body: indices are calculated from IV:
// ... loop body ...
// End of body: store into a[i]:
    a[i] = b[i] * c[i] * d[i];
  }
}

void runtime(float *a, float *b, float *c, float *d) {
  int x = 0;
  #pragma omp parallel for collapse(2) schedule(runtime)

// Loop header

  for (unsigned char i = '0' ; i <= '9'; ++i)
    for (x = -10; x < 10; ++x) {
// Start of body: indices are calculated from IV:
// ... loop body ...
// End of body: store into a[i]:
    a[i] = b[i] * c[i] * d[i];
  }
}

int foo() { extern void mayThrow(); mayThrow(); return 0; };

void parallel_for(float *a, const int n) {
  float arr[n];
#pragma omp parallel for schedule(static, 5) private(arr) default(none) firstprivate(n) shared(a)
  for (unsigned i = 131071; i <= 2147483647; i += 127)
    a[i] += foo() + arr[i] + n;
}
// Check source line corresponds to "#pragma omp parallel for schedule(static, 5)" above:

#else // OMP5
int increment () {
  #pragma omp for
// Determine UB = min(UB, GlobalUB)

// Loop header

  for (int i = 0 ; i != 5; ++i)
// Start of body: calculate i from IV:
    ;
  return 0;
}

int decrement_nowait () {
  #pragma omp for nowait
// Determine UB = min(UB, GlobalUB)

// Loop header
  for (int j = 5 ; j != 0; --j)
// Start of body: calculate i from IV:
    ;
  return 0;
}

void range_for_single() {
  int arr[10] = {0};
#pragma omp parallel for
  for (auto &a : arr)
    (void)a;
}


// __range = arr;

// __end = end(_range);


// calculate number of elements.

// __begin = begin(range);

// __begin >= __end ? goto then : goto exit;


// lb = 0;

// ub = number of elements

// stride = 1;

// is_last = 0;

// loop.

// ub = (ub > number_of_elems ? number_of_elems : ub);



// OMP%: store i64 [[MIN]], ptr [[UB]],

// iv = lb;

// goto loop;
// loop:


// iv <= ub ? goto body : goto end;

// body:
// __begin = begin(arr) + iv * 1;

// a = *__begin;

// (void)a;

// iv += 1;

// goto loop;

// end:
// exit:

void range_for_collapsed() {
  int arr[10] = {0};
#pragma omp parallel for collapse(2)
  for (auto &a : arr)
    for (auto b : arr)
      a = b;
}
#endif // OMP5

#endif // HEADER

// CHECK1-LABEL: define {{[^@]+}}@_Z17with_var_schedulev
// CHECK1-SAME: () #[[ATTR0:[0-9]+]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[A:%.*]] = alloca double, align 8
// CHECK1-NEXT:    [[DOTCAPTURE_EXPR_:%.*]] = alloca i8, align 1
// CHECK1-NEXT:    [[DOTCAPTURE_EXPR__CASTED:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[FREEZE_POISON:%.*]] = freeze double poison
// CHECK1-NEXT:    store double [[FREEZE_POISON]], ptr [[A]], align 8
// CHECK1-NEXT:    store double 5.000000e+00, ptr [[A]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i8 poison
// CHECK1-NEXT:    store i8 [[FREEZE_POISON1]], ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK1-NEXT:    [[TMP0:%.*]] = load double, ptr [[A]], align 8
// CHECK1-NEXT:    [[CONV:%.*]] = fptosi double [[TMP0]] to i8
// CHECK1-NEXT:    store i8 [[CONV]], ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK1-NEXT:    [[TMP1:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK1-NEXT:    store i8 [[TMP1]], ptr [[DOTCAPTURE_EXPR__CASTED]], align 1
// CHECK1-NEXT:    [[TMP2:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR__CASTED]], align 8, !freeze_bits [[META3:![0-9]+]]
// CHECK1-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2:[0-9]+]], i32 1, ptr @_Z17with_var_schedulev.omp_outlined, i64 [[TMP2]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z17with_var_schedulev.omp_outlined
// CHECK1-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], i64 noundef [[DOTCAPTURE_EXPR_:%.*]]) #[[ATTR1:[0-9]+]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTCAPTURE_EXPR__ADDR:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[TMP:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTCAPTURE_EXPR_1:%.*]] = alloca double, align 8
// CHECK1-NEXT:    [[DOTCAPTURE_EXPR_3:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[I:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[A:%.*]] = alloca double, align 8
// CHECK1-NEXT:    [[I12:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK1-NEXT:    store i64 [[DOTCAPTURE_EXPR_]], ptr [[DOTCAPTURE_EXPR__ADDR]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON2:%.*]] = freeze double poison
// CHECK1-NEXT:    store double [[FREEZE_POISON2]], ptr [[DOTCAPTURE_EXPR_1]], align 8
// CHECK1-NEXT:    [[TMP0:%.*]] = load double, ptr undef, align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[ADD:%.*]] = fadd double 2.000000e+00, [[TMP0]]
// CHECK1-NEXT:    store double [[ADD]], ptr [[DOTCAPTURE_EXPR_1]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON4]], ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK1-NEXT:    [[TMP1:%.*]] = load double, ptr [[DOTCAPTURE_EXPR_1]], align 8
// CHECK1-NEXT:    [[SUB:%.*]] = fsub double [[TMP1]], 1.000000e+00
// CHECK1-NEXT:    [[DIV:%.*]] = fdiv double [[SUB]], 1.000000e+00
// CHECK1-NEXT:    [[CONV:%.*]] = fptoui double [[DIV]] to i64
// CHECK1-NEXT:    [[SUB5:%.*]] = sub i64 [[CONV]], 1
// CHECK1-NEXT:    store i64 [[SUB5]], ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON6:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON6]], ptr [[I]], align 8
// CHECK1-NEXT:    store i64 1, ptr [[I]], align 8
// CHECK1-NEXT:    [[TMP2:%.*]] = load double, ptr [[DOTCAPTURE_EXPR_1]], align 8
// CHECK1-NEXT:    [[CMP:%.*]] = fcmp olt double 1.000000e+00, [[TMP2]]
// CHECK1-NEXT:    br i1 [[CMP]], label [[OMP_PRECOND_THEN:%.*]], label [[OMP_PRECOND_END:%.*]]
// CHECK1:       omp.precond.then:
// CHECK1-NEXT:    [[FREEZE_POISON7:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON7]], ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON8:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON8]], ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    [[TMP3:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK1-NEXT:    store i64 [[TMP3]], ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON9:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON9]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK1-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON10:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON10]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON11:%.*]] = freeze double poison
// CHECK1-NEXT:    store double [[FREEZE_POISON11]], ptr [[A]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON13:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON13]], ptr [[I12]], align 8
// CHECK1-NEXT:    [[TMP4:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR__ADDR]], align 1, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[CONV14:%.*]] = sext i8 [[TMP4]] to i64
// CHECK1-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    [[TMP6:%.*]] = load i32, ptr [[TMP5]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void @__kmpc_for_static_init_8u(ptr @[[GLOB1:[0-9]+]], i32 [[TMP6]], i32 33, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i64 1, i64 [[CONV14]])
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK1:       omp.dispatch.cond:
// CHECK1-NEXT:    [[TMP7:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    [[TMP8:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK1-NEXT:    [[CMP15:%.*]] = icmp ugt i64 [[TMP7]], [[TMP8]]
// CHECK1-NEXT:    br i1 [[CMP15]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK1:       cond.true:
// CHECK1-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK1-NEXT:    br label [[COND_END:%.*]]
// CHECK1:       cond.false:
// CHECK1-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    br label [[COND_END]]
// CHECK1:       cond.end:
// CHECK1-NEXT:    [[COND:%.*]] = phi i64 [ [[TMP9]], [[COND_TRUE]] ], [ [[TMP10]], [[COND_FALSE]] ]
// CHECK1-NEXT:    store i64 [[COND]], ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    [[TMP11:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    store i64 [[TMP11]], ptr [[DOTOMP_IV]], align 8
// CHECK1-NEXT:    [[TMP12:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK1-NEXT:    [[TMP13:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    [[ADD16:%.*]] = add i64 [[TMP13]], 1
// CHECK1-NEXT:    [[CMP17:%.*]] = icmp ult i64 [[TMP12]], [[ADD16]]
// CHECK1-NEXT:    br i1 [[CMP17]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK1:       omp.dispatch.body:
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK1:       omp.inner.for.cond:
// CHECK1-NEXT:    [[TMP14:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK1-NEXT:    [[TMP15:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    [[ADD18:%.*]] = add i64 [[TMP15]], 1
// CHECK1-NEXT:    [[CMP19:%.*]] = icmp ult i64 [[TMP14]], [[ADD18]]
// CHECK1-NEXT:    br i1 [[CMP19]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK1:       omp.inner.for.body:
// CHECK1-NEXT:    [[TMP16:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK1-NEXT:    [[MUL:%.*]] = mul i64 [[TMP16]], 1
// CHECK1-NEXT:    [[ADD20:%.*]] = add i64 1, [[MUL]]
// CHECK1-NEXT:    store i64 [[ADD20]], ptr [[I12]], align 8
// CHECK1-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK1:       omp.body.continue:
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK1:       omp.inner.for.inc:
// CHECK1-NEXT:    [[TMP17:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK1-NEXT:    [[ADD21:%.*]] = add i64 [[TMP17]], 1
// CHECK1-NEXT:    store i64 [[ADD21]], ptr [[DOTOMP_IV]], align 8
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK1:       omp.inner.for.end:
// CHECK1-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK1:       omp.dispatch.inc:
// CHECK1-NEXT:    [[TMP18:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    [[TMP19:%.*]] = load i64, ptr [[DOTOMP_STRIDE]], align 8
// CHECK1-NEXT:    [[ADD22:%.*]] = add i64 [[TMP18]], [[TMP19]]
// CHECK1-NEXT:    store i64 [[ADD22]], ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    [[TMP20:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    [[TMP21:%.*]] = load i64, ptr [[DOTOMP_STRIDE]], align 8
// CHECK1-NEXT:    [[ADD23:%.*]] = add i64 [[TMP20]], [[TMP21]]
// CHECK1-NEXT:    store i64 [[ADD23]], ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK1:       omp.dispatch.end:
// CHECK1-NEXT:    [[TMP22:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    [[TMP23:%.*]] = load i32, ptr [[TMP22]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP23]])
// CHECK1-NEXT:    br label [[OMP_PRECOND_END]]
// CHECK1:       omp.precond.end:
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z23without_schedule_clausePfS_S_S_
// CHECK1-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z23without_schedule_clausePfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z23without_schedule_clausePfS_S_S_.omp_outlined
// CHECK1-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6:![0-9]+]]
// CHECK1-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    store i32 4571423, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[I]], align 4
// CHECK1-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB1]], i32 [[TMP5]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1)
// CHECK1-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP6]], 4571423
// CHECK1-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK1:       cond.true:
// CHECK1-NEXT:    br label [[COND_END:%.*]]
// CHECK1:       cond.false:
// CHECK1-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    br label [[COND_END]]
// CHECK1:       cond.end:
// CHECK1-NEXT:    [[COND:%.*]] = phi i32 [ 4571423, [[COND_TRUE]] ], [ [[TMP7]], [[COND_FALSE]] ]
// CHECK1-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    store i32 [[TMP8]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK1:       omp.inner.for.cond:
// CHECK1-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[CMP6:%.*]] = icmp sle i32 [[TMP9]], [[TMP10]]
// CHECK1-NEXT:    br i1 [[CMP6]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK1:       omp.inner.for.body:
// CHECK1-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP11]], 7
// CHECK1-NEXT:    [[ADD:%.*]] = add nsw i32 33, [[MUL]]
// CHECK1-NEXT:    store i32 [[ADD]], ptr [[I]], align 4
// CHECK1-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[TMP1]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP13]] to i64
// CHECK1-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[TMP12]], i64 [[IDXPROM]]
// CHECK1-NEXT:    [[TMP14:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[TMP2]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP16:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM7:%.*]] = sext i32 [[TMP16]] to i64
// CHECK1-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[TMP15]], i64 [[IDXPROM7]]
// CHECK1-NEXT:    [[TMP17:%.*]] = load float, ptr [[ARRAYIDX8]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL9:%.*]] = fmul float [[TMP14]], [[TMP17]]
// CHECK1-NEXT:    [[TMP18:%.*]] = load ptr, ptr [[TMP3]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP19:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM10:%.*]] = sext i32 [[TMP19]] to i64
// CHECK1-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds float, ptr [[TMP18]], i64 [[IDXPROM10]]
// CHECK1-NEXT:    [[TMP20:%.*]] = load float, ptr [[ARRAYIDX11]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL12:%.*]] = fmul float [[MUL9]], [[TMP20]]
// CHECK1-NEXT:    [[TMP21:%.*]] = load ptr, ptr [[TMP0]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP22:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM13:%.*]] = sext i32 [[TMP22]] to i64
// CHECK1-NEXT:    [[ARRAYIDX14:%.*]] = getelementptr inbounds float, ptr [[TMP21]], i64 [[IDXPROM13]]
// CHECK1-NEXT:    store float [[MUL12]], ptr [[ARRAYIDX14]], align 4
// CHECK1-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK1:       omp.body.continue:
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK1:       omp.inner.for.inc:
// CHECK1-NEXT:    [[TMP23:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[ADD15:%.*]] = add nsw i32 [[TMP23]], 1
// CHECK1-NEXT:    store i32 [[ADD15]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK1:       omp.inner.for.end:
// CHECK1-NEXT:    br label [[OMP_LOOP_EXIT:%.*]]
// CHECK1:       omp.loop.exit:
// CHECK1-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP5]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z18static_not_chunkedPfS_S_S_
// CHECK1-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z18static_not_chunkedPfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z18static_not_chunkedPfS_S_S_.omp_outlined
// CHECK1-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    store i32 4571423, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[I]], align 4
// CHECK1-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB1]], i32 [[TMP5]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1)
// CHECK1-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP6]], 4571423
// CHECK1-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK1:       cond.true:
// CHECK1-NEXT:    br label [[COND_END:%.*]]
// CHECK1:       cond.false:
// CHECK1-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    br label [[COND_END]]
// CHECK1:       cond.end:
// CHECK1-NEXT:    [[COND:%.*]] = phi i32 [ 4571423, [[COND_TRUE]] ], [ [[TMP7]], [[COND_FALSE]] ]
// CHECK1-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    store i32 [[TMP8]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK1:       omp.inner.for.cond:
// CHECK1-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[CMP6:%.*]] = icmp sle i32 [[TMP9]], [[TMP10]]
// CHECK1-NEXT:    br i1 [[CMP6]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK1:       omp.inner.for.body:
// CHECK1-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP11]], 7
// CHECK1-NEXT:    [[SUB:%.*]] = sub nsw i32 32000000, [[MUL]]
// CHECK1-NEXT:    store i32 [[SUB]], ptr [[I]], align 4
// CHECK1-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[TMP1]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP13]] to i64
// CHECK1-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[TMP12]], i64 [[IDXPROM]]
// CHECK1-NEXT:    [[TMP14:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[TMP2]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP16:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM7:%.*]] = sext i32 [[TMP16]] to i64
// CHECK1-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[TMP15]], i64 [[IDXPROM7]]
// CHECK1-NEXT:    [[TMP17:%.*]] = load float, ptr [[ARRAYIDX8]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL9:%.*]] = fmul float [[TMP14]], [[TMP17]]
// CHECK1-NEXT:    [[TMP18:%.*]] = load ptr, ptr [[TMP3]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP19:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM10:%.*]] = sext i32 [[TMP19]] to i64
// CHECK1-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds float, ptr [[TMP18]], i64 [[IDXPROM10]]
// CHECK1-NEXT:    [[TMP20:%.*]] = load float, ptr [[ARRAYIDX11]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL12:%.*]] = fmul float [[MUL9]], [[TMP20]]
// CHECK1-NEXT:    [[TMP21:%.*]] = load ptr, ptr [[TMP0]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP22:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM13:%.*]] = sext i32 [[TMP22]] to i64
// CHECK1-NEXT:    [[ARRAYIDX14:%.*]] = getelementptr inbounds float, ptr [[TMP21]], i64 [[IDXPROM13]]
// CHECK1-NEXT:    store float [[MUL12]], ptr [[ARRAYIDX14]], align 4
// CHECK1-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK1:       omp.body.continue:
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK1:       omp.inner.for.inc:
// CHECK1-NEXT:    [[TMP23:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP23]], 1
// CHECK1-NEXT:    store i32 [[ADD]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK1:       omp.inner.for.end:
// CHECK1-NEXT:    br label [[OMP_LOOP_EXIT:%.*]]
// CHECK1:       omp.loop.exit:
// CHECK1-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP5]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z14static_chunkedPfS_S_S_
// CHECK1-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z14static_chunkedPfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z14static_chunkedPfS_S_S_.omp_outlined
// CHECK1-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    store i32 16908288, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[I]], align 4
// CHECK1-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void @__kmpc_for_static_init_4u(ptr @[[GLOB1]], i32 [[TMP5]], i32 33, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 5)
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK1:       omp.dispatch.cond:
// CHECK1-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[TMP6]], 16908288
// CHECK1-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK1:       cond.true:
// CHECK1-NEXT:    br label [[COND_END:%.*]]
// CHECK1:       cond.false:
// CHECK1-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    br label [[COND_END]]
// CHECK1:       cond.end:
// CHECK1-NEXT:    [[COND:%.*]] = phi i32 [ 16908288, [[COND_TRUE]] ], [ [[TMP7]], [[COND_FALSE]] ]
// CHECK1-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    store i32 [[TMP8]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[CMP6:%.*]] = icmp ule i32 [[TMP9]], [[TMP10]]
// CHECK1-NEXT:    br i1 [[CMP6]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK1:       omp.dispatch.body:
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK1:       omp.inner.for.cond:
// CHECK1-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[CMP7:%.*]] = icmp ule i32 [[TMP11]], [[TMP12]]
// CHECK1-NEXT:    br i1 [[CMP7]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK1:       omp.inner.for.body:
// CHECK1-NEXT:    [[TMP13:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[MUL:%.*]] = mul i32 [[TMP13]], 127
// CHECK1-NEXT:    [[ADD:%.*]] = add i32 131071, [[MUL]]
// CHECK1-NEXT:    store i32 [[ADD]], ptr [[I]], align 4
// CHECK1-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP1]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP15:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM:%.*]] = zext i32 [[TMP15]] to i64
// CHECK1-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP14]], i64 [[IDXPROM]]
// CHECK1-NEXT:    [[TMP16:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP2]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP18:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM8:%.*]] = zext i32 [[TMP18]] to i64
// CHECK1-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds nuw float, ptr [[TMP17]], i64 [[IDXPROM8]]
// CHECK1-NEXT:    [[TMP19:%.*]] = load float, ptr [[ARRAYIDX9]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL10:%.*]] = fmul float [[TMP16]], [[TMP19]]
// CHECK1-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[TMP3]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP21:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM11:%.*]] = zext i32 [[TMP21]] to i64
// CHECK1-NEXT:    [[ARRAYIDX12:%.*]] = getelementptr inbounds nuw float, ptr [[TMP20]], i64 [[IDXPROM11]]
// CHECK1-NEXT:    [[TMP22:%.*]] = load float, ptr [[ARRAYIDX12]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL13:%.*]] = fmul float [[MUL10]], [[TMP22]]
// CHECK1-NEXT:    [[TMP23:%.*]] = load ptr, ptr [[TMP0]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP24:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM14:%.*]] = zext i32 [[TMP24]] to i64
// CHECK1-NEXT:    [[ARRAYIDX15:%.*]] = getelementptr inbounds nuw float, ptr [[TMP23]], i64 [[IDXPROM14]]
// CHECK1-NEXT:    store float [[MUL13]], ptr [[ARRAYIDX15]], align 4
// CHECK1-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK1:       omp.body.continue:
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK1:       omp.inner.for.inc:
// CHECK1-NEXT:    [[TMP25:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[ADD16:%.*]] = add i32 [[TMP25]], 1
// CHECK1-NEXT:    store i32 [[ADD16]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK1:       omp.inner.for.end:
// CHECK1-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK1:       omp.dispatch.inc:
// CHECK1-NEXT:    [[TMP26:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    [[TMP27:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    [[ADD17:%.*]] = add i32 [[TMP26]], [[TMP27]]
// CHECK1-NEXT:    store i32 [[ADD17]], ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    [[TMP28:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[TMP29:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    [[ADD18:%.*]] = add i32 [[TMP28]], [[TMP29]]
// CHECK1-NEXT:    store i32 [[ADD18]], ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK1:       omp.dispatch.end:
// CHECK1-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP5]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z8dynamic1PfS_S_S_
// CHECK1-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z8dynamic1PfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z8dynamic1PfS_S_S_.omp_outlined
// CHECK1-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[TMP:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[I:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    store i64 16908287, ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK1-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON5]], ptr [[I]], align 8
// CHECK1-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void @__kmpc_dispatch_init_8u(ptr @[[GLOB2]], i32 [[TMP5]], i32 1073741859, i64 0, i64 16908287, i64 1, i64 1)
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK1:       omp.dispatch.cond:
// CHECK1-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_dispatch_next_8u(ptr @[[GLOB2]], i32 [[TMP5]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]])
// CHECK1-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP6]], 0
// CHECK1-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK1:       omp.dispatch.body:
// CHECK1-NEXT:    [[TMP7:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    store i64 [[TMP7]], ptr [[DOTOMP_IV]], align 8
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK1:       omp.inner.for.cond:
// CHECK1-NEXT:    [[TMP8:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP7:![0-9]+]]
// CHECK1-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK1-NEXT:    [[ADD:%.*]] = add i64 [[TMP9]], 1
// CHECK1-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TMP8]], [[ADD]]
// CHECK1-NEXT:    br i1 [[CMP]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK1:       omp.inner.for.body:
// CHECK1-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK1-NEXT:    [[MUL:%.*]] = mul i64 [[TMP10]], 127
// CHECK1-NEXT:    [[ADD6:%.*]] = add i64 131071, [[MUL]]
// CHECK1-NEXT:    store i64 [[ADD6]], ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK1-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[TMP1]], align 8, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP12:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK1-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP11]], i64 [[TMP12]]
// CHECK1-NEXT:    [[TMP13:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP2]], align 8, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP15:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK1-NEXT:    [[ARRAYIDX7:%.*]] = getelementptr inbounds nuw float, ptr [[TMP14]], i64 [[TMP15]]
// CHECK1-NEXT:    [[TMP16:%.*]] = load float, ptr [[ARRAYIDX7]], align 4, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL8:%.*]] = fmul float [[TMP13]], [[TMP16]]
// CHECK1-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP3]], align 8, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP18:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK1-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds nuw float, ptr [[TMP17]], i64 [[TMP18]]
// CHECK1-NEXT:    [[TMP19:%.*]] = load float, ptr [[ARRAYIDX9]], align 4, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL10:%.*]] = fmul float [[MUL8]], [[TMP19]]
// CHECK1-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[TMP0]], align 8, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP21:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK1-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds nuw float, ptr [[TMP20]], i64 [[TMP21]]
// CHECK1-NEXT:    store float [[MUL10]], ptr [[ARRAYIDX11]], align 4, !llvm.access.group [[ACC_GRP7]]
// CHECK1-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK1:       omp.body.continue:
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK1:       omp.inner.for.inc:
// CHECK1-NEXT:    [[TMP22:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK1-NEXT:    [[ADD12:%.*]] = add i64 [[TMP22]], 1
// CHECK1-NEXT:    store i64 [[ADD12]], ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND]], !llvm.loop [[LOOP8:![0-9]+]]
// CHECK1:       omp.inner.for.end:
// CHECK1-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK1:       omp.dispatch.inc:
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK1:       omp.dispatch.end:
// CHECK1-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB2]], i32 [[TMP5]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z7guided7PfS_S_S_
// CHECK1-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z7guided7PfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z7guided7PfS_S_S_.omp_outlined
// CHECK1-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[TMP:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[I:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    store i64 16908287, ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK1-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON5]], ptr [[I]], align 8
// CHECK1-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void @__kmpc_dispatch_init_8u(ptr @[[GLOB2]], i32 [[TMP5]], i32 1073741860, i64 0, i64 16908287, i64 1, i64 7)
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK1:       omp.dispatch.cond:
// CHECK1-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_dispatch_next_8u(ptr @[[GLOB2]], i32 [[TMP5]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]])
// CHECK1-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP6]], 0
// CHECK1-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK1:       omp.dispatch.body:
// CHECK1-NEXT:    [[TMP7:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    store i64 [[TMP7]], ptr [[DOTOMP_IV]], align 8
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK1:       omp.inner.for.cond:
// CHECK1-NEXT:    [[TMP8:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP10:![0-9]+]]
// CHECK1-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK1-NEXT:    [[ADD:%.*]] = add i64 [[TMP9]], 1
// CHECK1-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TMP8]], [[ADD]]
// CHECK1-NEXT:    br i1 [[CMP]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK1:       omp.inner.for.body:
// CHECK1-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK1-NEXT:    [[MUL:%.*]] = mul i64 [[TMP10]], 127
// CHECK1-NEXT:    [[ADD6:%.*]] = add i64 131071, [[MUL]]
// CHECK1-NEXT:    store i64 [[ADD6]], ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK1-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[TMP1]], align 8, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP12:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK1-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP11]], i64 [[TMP12]]
// CHECK1-NEXT:    [[TMP13:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP2]], align 8, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP15:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK1-NEXT:    [[ARRAYIDX7:%.*]] = getelementptr inbounds nuw float, ptr [[TMP14]], i64 [[TMP15]]
// CHECK1-NEXT:    [[TMP16:%.*]] = load float, ptr [[ARRAYIDX7]], align 4, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL8:%.*]] = fmul float [[TMP13]], [[TMP16]]
// CHECK1-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP3]], align 8, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP18:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK1-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds nuw float, ptr [[TMP17]], i64 [[TMP18]]
// CHECK1-NEXT:    [[TMP19:%.*]] = load float, ptr [[ARRAYIDX9]], align 4, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL10:%.*]] = fmul float [[MUL8]], [[TMP19]]
// CHECK1-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[TMP0]], align 8, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP21:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK1-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds nuw float, ptr [[TMP20]], i64 [[TMP21]]
// CHECK1-NEXT:    store float [[MUL10]], ptr [[ARRAYIDX11]], align 4, !llvm.access.group [[ACC_GRP10]]
// CHECK1-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK1:       omp.body.continue:
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK1:       omp.inner.for.inc:
// CHECK1-NEXT:    [[TMP22:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK1-NEXT:    [[ADD12:%.*]] = add i64 [[TMP22]], 1
// CHECK1-NEXT:    store i64 [[ADD12]], ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND]], !llvm.loop [[LOOP11:![0-9]+]]
// CHECK1:       omp.inner.for.end:
// CHECK1-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK1:       omp.dispatch.inc:
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK1:       omp.dispatch.end:
// CHECK1-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB2]], i32 [[TMP5]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z9test_autoPfS_S_S_
// CHECK1-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[Y:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON]], ptr [[X]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[X]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[Y]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[Y]], align 4
// CHECK1-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 5, ptr @_Z9test_autoPfS_S_S_.omp_outlined, ptr [[Y]], ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z9test_autoPfS_S_S_.omp_outlined
// CHECK1-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 4 dereferenceable(4) [[Y:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[Y_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[TMP:%.*]] = alloca i8, align 1
// CHECK1-NEXT:    [[_TMP1:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTCAPTURE_EXPR_:%.*]] = alloca i8, align 1
// CHECK1-NEXT:    [[DOTCAPTURE_EXPR_3:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[I:%.*]] = alloca i8, align 1
// CHECK1-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[I15:%.*]] = alloca i8, align 1
// CHECK1-NEXT:    [[X17:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[Y]], ptr [[Y_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[Y_ADDR]], align 8, !nonnull [[META3]], !align [[META13:![0-9]+]]
// CHECK1-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i8 poison
// CHECK1-NEXT:    store i8 [[FREEZE_POISON2]], ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK1-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP0]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[CONV:%.*]] = trunc i32 [[TMP5]] to i8
// CHECK1-NEXT:    store i8 [[CONV]], ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK1-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON4]], ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK1-NEXT:    [[TMP6:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK1-NEXT:    [[CONV5:%.*]] = sext i8 [[TMP6]] to i32
// CHECK1-NEXT:    [[SUB:%.*]] = sub i32 57, [[CONV5]]
// CHECK1-NEXT:    [[ADD:%.*]] = add i32 [[SUB]], 1
// CHECK1-NEXT:    [[DIV:%.*]] = udiv i32 [[ADD]], 1
// CHECK1-NEXT:    [[CONV6:%.*]] = zext i32 [[DIV]] to i64
// CHECK1-NEXT:    [[MUL:%.*]] = mul nsw i64 [[CONV6]], 11
// CHECK1-NEXT:    [[SUB7:%.*]] = sub nsw i64 [[MUL]], 1
// CHECK1-NEXT:    store i64 [[SUB7]], ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON8:%.*]] = freeze i8 poison
// CHECK1-NEXT:    store i8 [[FREEZE_POISON8]], ptr [[I]], align 1
// CHECK1-NEXT:    [[FREEZE_POISON9:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON9]], ptr [[X]], align 4
// CHECK1-NEXT:    [[TMP7:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK1-NEXT:    store i8 [[TMP7]], ptr [[I]], align 1
// CHECK1-NEXT:    store i32 11, ptr [[X]], align 4
// CHECK1-NEXT:    [[TMP8:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK1-NEXT:    [[CONV10:%.*]] = sext i8 [[TMP8]] to i32
// CHECK1-NEXT:    [[CMP:%.*]] = icmp sle i32 [[CONV10]], 57
// CHECK1-NEXT:    br i1 [[CMP]], label [[OMP_PRECOND_THEN:%.*]], label [[OMP_PRECOND_END:%.*]]
// CHECK1:       omp.precond.then:
// CHECK1-NEXT:    [[FREEZE_POISON11:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON11]], ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON12:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON12]], ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK1-NEXT:    store i64 [[TMP9]], ptr [[DOTOMP_UB]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON13:%.*]] = freeze i64 poison
// CHECK1-NEXT:    store i64 [[FREEZE_POISON13]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK1-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON14:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON14]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON16:%.*]] = freeze i8 poison
// CHECK1-NEXT:    store i8 [[FREEZE_POISON16]], ptr [[I15]], align 1
// CHECK1-NEXT:    [[FREEZE_POISON18:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON18]], ptr [[X17]], align 4
// CHECK1-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK1-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    [[TMP12:%.*]] = load i32, ptr [[TMP11]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void @__kmpc_dispatch_init_8(ptr @[[GLOB2]], i32 [[TMP12]], i32 1073741862, i64 0, i64 [[TMP10]], i64 1, i64 1)
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK1:       omp.dispatch.cond:
// CHECK1-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    [[TMP14:%.*]] = load i32, ptr [[TMP13]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP15:%.*]] = call i32 @__kmpc_dispatch_next_8(ptr @[[GLOB2]], i32 [[TMP14]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]])
// CHECK1-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP15]], 0
// CHECK1-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK1:       omp.dispatch.body:
// CHECK1-NEXT:    [[TMP16:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK1-NEXT:    store i64 [[TMP16]], ptr [[DOTOMP_IV]], align 8
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK1:       omp.inner.for.cond:
// CHECK1-NEXT:    [[TMP17:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14:![0-9]+]]
// CHECK1-NEXT:    [[TMP18:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    [[CMP19:%.*]] = icmp sle i64 [[TMP17]], [[TMP18]]
// CHECK1-NEXT:    br i1 [[CMP19]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK1:       omp.inner.for.body:
// CHECK1-NEXT:    [[TMP19:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    [[CONV20:%.*]] = sext i8 [[TMP19]] to i64
// CHECK1-NEXT:    [[TMP20:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    [[DIV21:%.*]] = sdiv i64 [[TMP20]], 11
// CHECK1-NEXT:    [[MUL22:%.*]] = mul nsw i64 [[DIV21]], 1
// CHECK1-NEXT:    [[ADD23:%.*]] = add nsw i64 [[CONV20]], [[MUL22]]
// CHECK1-NEXT:    [[CONV24:%.*]] = trunc i64 [[ADD23]] to i8
// CHECK1-NEXT:    store i8 [[CONV24]], ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    [[TMP21:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    [[TMP22:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    [[DIV25:%.*]] = sdiv i64 [[TMP22]], 11
// CHECK1-NEXT:    [[MUL26:%.*]] = mul nsw i64 [[DIV25]], 11
// CHECK1-NEXT:    [[SUB27:%.*]] = sub nsw i64 [[TMP21]], [[MUL26]]
// CHECK1-NEXT:    [[MUL28:%.*]] = mul nsw i64 [[SUB27]], 1
// CHECK1-NEXT:    [[SUB29:%.*]] = sub nsw i64 11, [[MUL28]]
// CHECK1-NEXT:    [[CONV30:%.*]] = trunc i64 [[SUB29]] to i32
// CHECK1-NEXT:    store i32 [[CONV30]], ptr [[X17]], align 4, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    [[TMP23:%.*]] = load ptr, ptr [[TMP2]], align 8, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP24:%.*]] = load i8, ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    [[IDXPROM:%.*]] = sext i8 [[TMP24]] to i64
// CHECK1-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[TMP23]], i64 [[IDXPROM]]
// CHECK1-NEXT:    [[TMP25:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP26:%.*]] = load ptr, ptr [[TMP3]], align 8, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP27:%.*]] = load i8, ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    [[IDXPROM31:%.*]] = sext i8 [[TMP27]] to i64
// CHECK1-NEXT:    [[ARRAYIDX32:%.*]] = getelementptr inbounds float, ptr [[TMP26]], i64 [[IDXPROM31]]
// CHECK1-NEXT:    [[TMP28:%.*]] = load float, ptr [[ARRAYIDX32]], align 4, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL33:%.*]] = fmul float [[TMP25]], [[TMP28]]
// CHECK1-NEXT:    [[TMP29:%.*]] = load ptr, ptr [[TMP4]], align 8, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP30:%.*]] = load i8, ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    [[IDXPROM34:%.*]] = sext i8 [[TMP30]] to i64
// CHECK1-NEXT:    [[ARRAYIDX35:%.*]] = getelementptr inbounds float, ptr [[TMP29]], i64 [[IDXPROM34]]
// CHECK1-NEXT:    [[TMP31:%.*]] = load float, ptr [[ARRAYIDX35]], align 4, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL36:%.*]] = fmul float [[MUL33]], [[TMP31]]
// CHECK1-NEXT:    [[TMP32:%.*]] = load ptr, ptr [[TMP1]], align 8, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP33:%.*]] = load i8, ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    [[IDXPROM37:%.*]] = sext i8 [[TMP33]] to i64
// CHECK1-NEXT:    [[ARRAYIDX38:%.*]] = getelementptr inbounds float, ptr [[TMP32]], i64 [[IDXPROM37]]
// CHECK1-NEXT:    store float [[MUL36]], ptr [[ARRAYIDX38]], align 4, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK1:       omp.body.continue:
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK1:       omp.inner.for.inc:
// CHECK1-NEXT:    [[TMP34:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    [[ADD39:%.*]] = add nsw i64 [[TMP34]], 1
// CHECK1-NEXT:    store i64 [[ADD39]], ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND]], !llvm.loop [[LOOP15:![0-9]+]]
// CHECK1:       omp.inner.for.end:
// CHECK1-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK1:       omp.dispatch.inc:
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK1:       omp.dispatch.end:
// CHECK1-NEXT:    [[TMP35:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    [[TMP36:%.*]] = load i32, ptr [[TMP35]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB2]], i32 [[TMP36]])
// CHECK1-NEXT:    br label [[OMP_PRECOND_END]]
// CHECK1:       omp.precond.end:
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z7runtimePfS_S_S_
// CHECK1-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON]], ptr [[X]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[X]], align 4
// CHECK1-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z7runtimePfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z7runtimePfS_S_S_.omp_outlined
// CHECK1-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[TMP:%.*]] = alloca i8, align 1
// CHECK1-NEXT:    [[_TMP1:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[I:%.*]] = alloca i8, align 1
// CHECK1-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK1-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK1-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    store i32 199, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON6:%.*]] = freeze i8 poison
// CHECK1-NEXT:    store i8 [[FREEZE_POISON6]], ptr [[I]], align 1
// CHECK1-NEXT:    [[FREEZE_POISON7:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON7]], ptr [[X]], align 4
// CHECK1-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void @__kmpc_dispatch_init_4(ptr @[[GLOB2]], i32 [[TMP5]], i32 1073741861, i32 0, i32 199, i32 1, i32 1)
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK1:       omp.dispatch.cond:
// CHECK1-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_dispatch_next_4(ptr @[[GLOB2]], i32 [[TMP5]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]])
// CHECK1-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP6]], 0
// CHECK1-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK1:       omp.dispatch.body:
// CHECK1-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    store i32 [[TMP7]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK1:       omp.inner.for.cond:
// CHECK1-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17:![0-9]+]]
// CHECK1-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK1-NEXT:    [[CMP:%.*]] = icmp sle i32 [[TMP8]], [[TMP9]]
// CHECK1-NEXT:    br i1 [[CMP]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK1:       omp.inner.for.body:
// CHECK1-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK1-NEXT:    [[DIV:%.*]] = sdiv i32 [[TMP10]], 20
// CHECK1-NEXT:    [[MUL:%.*]] = mul nsw i32 [[DIV]], 1
// CHECK1-NEXT:    [[ADD:%.*]] = add nsw i32 48, [[MUL]]
// CHECK1-NEXT:    [[CONV:%.*]] = trunc i32 [[ADD]] to i8
// CHECK1-NEXT:    store i8 [[CONV]], ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK1-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK1-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK1-NEXT:    [[DIV8:%.*]] = sdiv i32 [[TMP12]], 20
// CHECK1-NEXT:    [[MUL9:%.*]] = mul nsw i32 [[DIV8]], 20
// CHECK1-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP11]], [[MUL9]]
// CHECK1-NEXT:    [[MUL10:%.*]] = mul nsw i32 [[SUB]], 1
// CHECK1-NEXT:    [[ADD11:%.*]] = add nsw i32 -10, [[MUL10]]
// CHECK1-NEXT:    store i32 [[ADD11]], ptr [[X]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK1-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[TMP1]], align 8, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP14:%.*]] = load i8, ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK1-NEXT:    [[IDXPROM:%.*]] = zext i8 [[TMP14]] to i64
// CHECK1-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP13]], i64 [[IDXPROM]]
// CHECK1-NEXT:    [[TMP15:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[TMP2]], align 8, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP17:%.*]] = load i8, ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK1-NEXT:    [[IDXPROM12:%.*]] = zext i8 [[TMP17]] to i64
// CHECK1-NEXT:    [[ARRAYIDX13:%.*]] = getelementptr inbounds nuw float, ptr [[TMP16]], i64 [[IDXPROM12]]
// CHECK1-NEXT:    [[TMP18:%.*]] = load float, ptr [[ARRAYIDX13]], align 4, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL14:%.*]] = fmul float [[TMP15]], [[TMP18]]
// CHECK1-NEXT:    [[TMP19:%.*]] = load ptr, ptr [[TMP3]], align 8, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP20:%.*]] = load i8, ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK1-NEXT:    [[IDXPROM15:%.*]] = zext i8 [[TMP20]] to i64
// CHECK1-NEXT:    [[ARRAYIDX16:%.*]] = getelementptr inbounds nuw float, ptr [[TMP19]], i64 [[IDXPROM15]]
// CHECK1-NEXT:    [[TMP21:%.*]] = load float, ptr [[ARRAYIDX16]], align 4, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[MUL17:%.*]] = fmul float [[MUL14]], [[TMP21]]
// CHECK1-NEXT:    [[TMP22:%.*]] = load ptr, ptr [[TMP0]], align 8, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP23:%.*]] = load i8, ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK1-NEXT:    [[IDXPROM18:%.*]] = zext i8 [[TMP23]] to i64
// CHECK1-NEXT:    [[ARRAYIDX19:%.*]] = getelementptr inbounds nuw float, ptr [[TMP22]], i64 [[IDXPROM18]]
// CHECK1-NEXT:    store float [[MUL17]], ptr [[ARRAYIDX19]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK1-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK1:       omp.body.continue:
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK1:       omp.inner.for.inc:
// CHECK1-NEXT:    [[TMP24:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK1-NEXT:    [[ADD20:%.*]] = add nsw i32 [[TMP24]], 1
// CHECK1-NEXT:    store i32 [[ADD20]], ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND]], !llvm.loop [[LOOP18:![0-9]+]]
// CHECK1:       omp.inner.for.end:
// CHECK1-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK1:       omp.dispatch.inc:
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK1:       omp.dispatch.end:
// CHECK1-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB2]], i32 [[TMP5]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z3foov
// CHECK1-SAME: () #[[ATTR3:[0-9]+]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    call void @_Z8mayThrowv()
// CHECK1-NEXT:    ret i32 0
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z12parallel_forPfi
// CHECK1-SAME: (ptr noundef [[A:%.*]], i32 noundef [[N:%.*]]) #[[ATTR0]] {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[N_ADDR:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[SAVED_STACK:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[N_CASTED:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store i32 [[N]], ptr [[N_ADDR]], align 4
// CHECK1-NEXT:    [[TMP0:%.*]] = load i32, ptr [[N_ADDR]], align 4
// CHECK1-NEXT:    [[TMP1:%.*]] = zext i32 [[TMP0]] to i64
// CHECK1-NEXT:    [[TMP2:%.*]] = call ptr @llvm.stacksave.p0()
// CHECK1-NEXT:    store ptr [[TMP2]], ptr [[SAVED_STACK]], align 8
// CHECK1-NEXT:    [[VLA:%.*]] = alloca float, i64 [[TMP1]], align 16
// CHECK1-NEXT:    store i64 [[TMP1]], ptr [[__VLA_EXPR0]], align 8
// CHECK1-NEXT:    [[TMP3:%.*]] = load i32, ptr [[N_ADDR]], align 4
// CHECK1-NEXT:    store i32 [[TMP3]], ptr [[N_CASTED]], align 4
// CHECK1-NEXT:    [[TMP4:%.*]] = load i64, ptr [[N_CASTED]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 3, ptr @_Z12parallel_forPfi.omp_outlined, ptr [[A_ADDR]], i64 [[TMP1]], i64 [[TMP4]])
// CHECK1-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[SAVED_STACK]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void @llvm.stackrestore.p0(ptr [[TMP5]])
// CHECK1-NEXT:    ret void
//
//
// CHECK1-LABEL: define {{[^@]+}}@_Z12parallel_forPfi.omp_outlined
// CHECK1-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], i64 noundef [[VLA:%.*]], i64 noundef [[N:%.*]]) #[[ATTR1]] personality ptr @__gxx_personality_v0 {
// CHECK1-NEXT:  entry:
// CHECK1-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[VLA_ADDR:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[N_ADDR:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    [[SAVED_STACK:%.*]] = alloca ptr, align 8
// CHECK1-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i64, align 8
// CHECK1-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK1-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK1-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK1-NEXT:    store i64 [[VLA]], ptr [[VLA_ADDR]], align 8
// CHECK1-NEXT:    store i64 [[N]], ptr [[N_ADDR]], align 8
// CHECK1-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK1-NEXT:    [[TMP1:%.*]] = load i64, ptr [[VLA_ADDR]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    store i32 16908288, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK1-NEXT:    [[TMP2:%.*]] = call ptr @llvm.stacksave.p0()
// CHECK1-NEXT:    store ptr [[TMP2]], ptr [[SAVED_STACK]], align 8
// CHECK1-NEXT:    [[VLA5:%.*]] = alloca float, i64 [[TMP1]], align 16
// CHECK1-NEXT:    store i64 [[TMP1]], ptr [[__VLA_EXPR0]], align 8
// CHECK1-NEXT:    [[FREEZE_POISON6:%.*]] = freeze i32 poison
// CHECK1-NEXT:    store i32 [[FREEZE_POISON6]], ptr [[I]], align 4
// CHECK1-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK1-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP3]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void @__kmpc_for_static_init_4u(ptr @[[GLOB1]], i32 [[TMP4]], i32 33, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 5)
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK1:       omp.dispatch.cond:
// CHECK1-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[TMP5]], 16908288
// CHECK1-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK1:       cond.true:
// CHECK1-NEXT:    br label [[COND_END:%.*]]
// CHECK1:       cond.false:
// CHECK1-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    br label [[COND_END]]
// CHECK1:       cond.end:
// CHECK1-NEXT:    [[COND:%.*]] = phi i32 [ 16908288, [[COND_TRUE]] ], [ [[TMP6]], [[COND_FALSE]] ]
// CHECK1-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    store i32 [[TMP7]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[CMP7:%.*]] = icmp ule i32 [[TMP8]], [[TMP9]]
// CHECK1-NEXT:    br i1 [[CMP7]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_CLEANUP:%.*]]
// CHECK1:       omp.dispatch.cleanup:
// CHECK1-NEXT:    br label [[OMP_DISPATCH_END:%.*]]
// CHECK1:       omp.dispatch.body:
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK1:       omp.inner.for.cond:
// CHECK1-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[CMP8:%.*]] = icmp ule i32 [[TMP10]], [[TMP11]]
// CHECK1-NEXT:    br i1 [[CMP8]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_COND_CLEANUP:%.*]]
// CHECK1:       omp.inner.for.cond.cleanup:
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_END:%.*]]
// CHECK1:       omp.inner.for.body:
// CHECK1-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[MUL:%.*]] = mul i32 [[TMP12]], 127
// CHECK1-NEXT:    [[ADD:%.*]] = add i32 131071, [[MUL]]
// CHECK1-NEXT:    store i32 [[ADD]], ptr [[I]], align 4
// CHECK1-NEXT:    [[CALL:%.*]] = invoke noundef i32 @_Z3foov()
// CHECK1-NEXT:            to label [[INVOKE_CONT:%.*]] unwind label [[TERMINATE_LPAD:%.*]]
// CHECK1:       invoke.cont:
// CHECK1-NEXT:    [[CONV:%.*]] = sitofp i32 [[CALL]] to float
// CHECK1-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM:%.*]] = zext i32 [[TMP13]] to i64
// CHECK1-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[VLA5]], i64 [[IDXPROM]]
// CHECK1-NEXT:    [[TMP14:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[ADD9:%.*]] = fadd float [[CONV]], [[TMP14]]
// CHECK1-NEXT:    [[TMP15:%.*]] = load i32, ptr [[N_ADDR]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[CONV10:%.*]] = sitofp i32 [[TMP15]] to float
// CHECK1-NEXT:    [[ADD11:%.*]] = fadd float [[ADD9]], [[CONV10]]
// CHECK1-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[TMP0]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[TMP17:%.*]] = load i32, ptr [[I]], align 4
// CHECK1-NEXT:    [[IDXPROM12:%.*]] = zext i32 [[TMP17]] to i64
// CHECK1-NEXT:    [[ARRAYIDX13:%.*]] = getelementptr inbounds nuw float, ptr [[TMP16]], i64 [[IDXPROM12]]
// CHECK1-NEXT:    [[TMP18:%.*]] = load float, ptr [[ARRAYIDX13]], align 4, !freeze_bits [[META3]]
// CHECK1-NEXT:    [[ADD14:%.*]] = fadd float [[TMP18]], [[ADD11]]
// CHECK1-NEXT:    store float [[ADD14]], ptr [[ARRAYIDX13]], align 4
// CHECK1-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK1:       omp.body.continue:
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK1:       omp.inner.for.inc:
// CHECK1-NEXT:    [[TMP19:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    [[ADD15:%.*]] = add i32 [[TMP19]], 1
// CHECK1-NEXT:    store i32 [[ADD15]], ptr [[DOTOMP_IV]], align 4
// CHECK1-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK1:       omp.inner.for.end:
// CHECK1-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK1:       omp.dispatch.inc:
// CHECK1-NEXT:    [[TMP20:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    [[TMP21:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    [[ADD16:%.*]] = add i32 [[TMP20]], [[TMP21]]
// CHECK1-NEXT:    store i32 [[ADD16]], ptr [[DOTOMP_LB]], align 4
// CHECK1-NEXT:    [[TMP22:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    [[TMP23:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4
// CHECK1-NEXT:    [[ADD17:%.*]] = add i32 [[TMP22]], [[TMP23]]
// CHECK1-NEXT:    store i32 [[ADD17]], ptr [[DOTOMP_UB]], align 4
// CHECK1-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK1:       omp.dispatch.end:
// CHECK1-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP4]])
// CHECK1-NEXT:    [[TMP24:%.*]] = load ptr, ptr [[SAVED_STACK]], align 8, !freeze_bits [[META3]]
// CHECK1-NEXT:    call void @llvm.stackrestore.p0(ptr [[TMP24]])
// CHECK1-NEXT:    ret void
// CHECK1:       terminate.lpad:
// CHECK1-NEXT:    [[TMP25:%.*]] = landingpad { ptr, i32 }
// CHECK1-NEXT:            catch ptr null
// CHECK1-NEXT:    [[TMP26:%.*]] = extractvalue { ptr, i32 } [[TMP25]], 0
// CHECK1-NEXT:    call void @__clang_call_terminate(ptr [[TMP26]]) #[[ATTR7:[0-9]+]]
// CHECK1-NEXT:    unreachable
//
//
// CHECK1-LABEL: define {{[^@]+}}@__clang_call_terminate
// CHECK1-SAME: (ptr noundef [[TMP0:%.*]]) #[[ATTR6:[0-9]+]] comdat {
// CHECK1-NEXT:    [[TMP2:%.*]] = call ptr @__cxa_begin_catch(ptr [[TMP0]]) #[[ATTR2:[0-9]+]]
// CHECK1-NEXT:    call void @_ZSt9terminatev() #[[ATTR7]]
// CHECK1-NEXT:    unreachable
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z17with_var_schedulev
// CHECK2-SAME: () #[[ATTR0:[0-9]+]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[A:%.*]] = alloca double, align 8
// CHECK2-NEXT:    [[DOTCAPTURE_EXPR_:%.*]] = alloca i8, align 1
// CHECK2-NEXT:    [[DOTCAPTURE_EXPR__CASTED:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[FREEZE_POISON:%.*]] = freeze double poison
// CHECK2-NEXT:    store double [[FREEZE_POISON]], ptr [[A]], align 8
// CHECK2-NEXT:    store double 5.000000e+00, ptr [[A]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i8 poison
// CHECK2-NEXT:    store i8 [[FREEZE_POISON1]], ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK2-NEXT:    [[TMP0:%.*]] = load double, ptr [[A]], align 8
// CHECK2-NEXT:    [[CONV:%.*]] = fptosi double [[TMP0]] to i8
// CHECK2-NEXT:    store i8 [[CONV]], ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK2-NEXT:    [[TMP1:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK2-NEXT:    store i8 [[TMP1]], ptr [[DOTCAPTURE_EXPR__CASTED]], align 1
// CHECK2-NEXT:    [[TMP2:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR__CASTED]], align 8, !freeze_bits [[META3:![0-9]+]]
// CHECK2-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2:[0-9]+]], i32 1, ptr @_Z17with_var_schedulev.omp_outlined, i64 [[TMP2]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z17with_var_schedulev.omp_outlined
// CHECK2-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], i64 noundef [[DOTCAPTURE_EXPR_:%.*]]) #[[ATTR1:[0-9]+]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTCAPTURE_EXPR__ADDR:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[TMP:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTCAPTURE_EXPR_1:%.*]] = alloca double, align 8
// CHECK2-NEXT:    [[DOTCAPTURE_EXPR_3:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[I:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[A:%.*]] = alloca double, align 8
// CHECK2-NEXT:    [[I12:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK2-NEXT:    store i64 [[DOTCAPTURE_EXPR_]], ptr [[DOTCAPTURE_EXPR__ADDR]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON2:%.*]] = freeze double poison
// CHECK2-NEXT:    store double [[FREEZE_POISON2]], ptr [[DOTCAPTURE_EXPR_1]], align 8
// CHECK2-NEXT:    [[TMP0:%.*]] = load double, ptr undef, align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[ADD:%.*]] = fadd double 2.000000e+00, [[TMP0]]
// CHECK2-NEXT:    store double [[ADD]], ptr [[DOTCAPTURE_EXPR_1]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON4]], ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK2-NEXT:    [[TMP1:%.*]] = load double, ptr [[DOTCAPTURE_EXPR_1]], align 8
// CHECK2-NEXT:    [[SUB:%.*]] = fsub double [[TMP1]], 1.000000e+00
// CHECK2-NEXT:    [[DIV:%.*]] = fdiv double [[SUB]], 1.000000e+00
// CHECK2-NEXT:    [[CONV:%.*]] = fptoui double [[DIV]] to i64
// CHECK2-NEXT:    [[SUB5:%.*]] = sub i64 [[CONV]], 1
// CHECK2-NEXT:    store i64 [[SUB5]], ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON6:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON6]], ptr [[I]], align 8
// CHECK2-NEXT:    store i64 1, ptr [[I]], align 8
// CHECK2-NEXT:    [[TMP2:%.*]] = load double, ptr [[DOTCAPTURE_EXPR_1]], align 8
// CHECK2-NEXT:    [[CMP:%.*]] = fcmp olt double 1.000000e+00, [[TMP2]]
// CHECK2-NEXT:    br i1 [[CMP]], label [[OMP_PRECOND_THEN:%.*]], label [[OMP_PRECOND_END:%.*]]
// CHECK2:       omp.precond.then:
// CHECK2-NEXT:    [[FREEZE_POISON7:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON7]], ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON8:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON8]], ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    [[TMP3:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK2-NEXT:    store i64 [[TMP3]], ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON9:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON9]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK2-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON10:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON10]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON11:%.*]] = freeze double poison
// CHECK2-NEXT:    store double [[FREEZE_POISON11]], ptr [[A]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON13:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON13]], ptr [[I12]], align 8
// CHECK2-NEXT:    [[TMP4:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR__ADDR]], align 1, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[CONV14:%.*]] = sext i8 [[TMP4]] to i64
// CHECK2-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    [[TMP6:%.*]] = load i32, ptr [[TMP5]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void @__kmpc_for_static_init_8u(ptr @[[GLOB1:[0-9]+]], i32 [[TMP6]], i32 33, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i64 1, i64 [[CONV14]])
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK2:       omp.dispatch.cond:
// CHECK2-NEXT:    [[TMP7:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    [[TMP8:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK2-NEXT:    [[CMP15:%.*]] = icmp ugt i64 [[TMP7]], [[TMP8]]
// CHECK2-NEXT:    br i1 [[CMP15]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK2:       cond.true:
// CHECK2-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK2-NEXT:    br label [[COND_END:%.*]]
// CHECK2:       cond.false:
// CHECK2-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    br label [[COND_END]]
// CHECK2:       cond.end:
// CHECK2-NEXT:    [[COND:%.*]] = phi i64 [ [[TMP9]], [[COND_TRUE]] ], [ [[TMP10]], [[COND_FALSE]] ]
// CHECK2-NEXT:    store i64 [[COND]], ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    [[TMP11:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    store i64 [[TMP11]], ptr [[DOTOMP_IV]], align 8
// CHECK2-NEXT:    [[TMP12:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK2-NEXT:    [[TMP13:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    [[ADD16:%.*]] = add i64 [[TMP13]], 1
// CHECK2-NEXT:    [[CMP17:%.*]] = icmp ult i64 [[TMP12]], [[ADD16]]
// CHECK2-NEXT:    br i1 [[CMP17]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK2:       omp.dispatch.body:
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK2:       omp.inner.for.cond:
// CHECK2-NEXT:    [[TMP14:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK2-NEXT:    [[TMP15:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    [[ADD18:%.*]] = add i64 [[TMP15]], 1
// CHECK2-NEXT:    [[CMP19:%.*]] = icmp ult i64 [[TMP14]], [[ADD18]]
// CHECK2-NEXT:    br i1 [[CMP19]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK2:       omp.inner.for.body:
// CHECK2-NEXT:    [[TMP16:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK2-NEXT:    [[MUL:%.*]] = mul i64 [[TMP16]], 1
// CHECK2-NEXT:    [[ADD20:%.*]] = add i64 1, [[MUL]]
// CHECK2-NEXT:    store i64 [[ADD20]], ptr [[I12]], align 8
// CHECK2-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK2:       omp.body.continue:
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK2:       omp.inner.for.inc:
// CHECK2-NEXT:    [[TMP17:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK2-NEXT:    [[ADD21:%.*]] = add i64 [[TMP17]], 1
// CHECK2-NEXT:    store i64 [[ADD21]], ptr [[DOTOMP_IV]], align 8
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK2:       omp.inner.for.end:
// CHECK2-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK2:       omp.dispatch.inc:
// CHECK2-NEXT:    [[TMP18:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    [[TMP19:%.*]] = load i64, ptr [[DOTOMP_STRIDE]], align 8
// CHECK2-NEXT:    [[ADD22:%.*]] = add i64 [[TMP18]], [[TMP19]]
// CHECK2-NEXT:    store i64 [[ADD22]], ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    [[TMP20:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    [[TMP21:%.*]] = load i64, ptr [[DOTOMP_STRIDE]], align 8
// CHECK2-NEXT:    [[ADD23:%.*]] = add i64 [[TMP20]], [[TMP21]]
// CHECK2-NEXT:    store i64 [[ADD23]], ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK2:       omp.dispatch.end:
// CHECK2-NEXT:    [[TMP22:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    [[TMP23:%.*]] = load i32, ptr [[TMP22]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP23]])
// CHECK2-NEXT:    br label [[OMP_PRECOND_END]]
// CHECK2:       omp.precond.end:
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z23without_schedule_clausePfS_S_S_
// CHECK2-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z23without_schedule_clausePfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z23without_schedule_clausePfS_S_S_.omp_outlined
// CHECK2-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6:![0-9]+]]
// CHECK2-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    store i32 4571423, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[I]], align 4
// CHECK2-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB1]], i32 [[TMP5]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1)
// CHECK2-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP6]], 4571423
// CHECK2-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK2:       cond.true:
// CHECK2-NEXT:    br label [[COND_END:%.*]]
// CHECK2:       cond.false:
// CHECK2-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    br label [[COND_END]]
// CHECK2:       cond.end:
// CHECK2-NEXT:    [[COND:%.*]] = phi i32 [ 4571423, [[COND_TRUE]] ], [ [[TMP7]], [[COND_FALSE]] ]
// CHECK2-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    store i32 [[TMP8]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK2:       omp.inner.for.cond:
// CHECK2-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[CMP6:%.*]] = icmp sle i32 [[TMP9]], [[TMP10]]
// CHECK2-NEXT:    br i1 [[CMP6]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK2:       omp.inner.for.body:
// CHECK2-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP11]], 7
// CHECK2-NEXT:    [[ADD:%.*]] = add nsw i32 33, [[MUL]]
// CHECK2-NEXT:    store i32 [[ADD]], ptr [[I]], align 4
// CHECK2-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[TMP1]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP13]] to i64
// CHECK2-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[TMP12]], i64 [[IDXPROM]]
// CHECK2-NEXT:    [[TMP14:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[TMP2]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP16:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM7:%.*]] = sext i32 [[TMP16]] to i64
// CHECK2-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[TMP15]], i64 [[IDXPROM7]]
// CHECK2-NEXT:    [[TMP17:%.*]] = load float, ptr [[ARRAYIDX8]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL9:%.*]] = fmul float [[TMP14]], [[TMP17]]
// CHECK2-NEXT:    [[TMP18:%.*]] = load ptr, ptr [[TMP3]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP19:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM10:%.*]] = sext i32 [[TMP19]] to i64
// CHECK2-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds float, ptr [[TMP18]], i64 [[IDXPROM10]]
// CHECK2-NEXT:    [[TMP20:%.*]] = load float, ptr [[ARRAYIDX11]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL12:%.*]] = fmul float [[MUL9]], [[TMP20]]
// CHECK2-NEXT:    [[TMP21:%.*]] = load ptr, ptr [[TMP0]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP22:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM13:%.*]] = sext i32 [[TMP22]] to i64
// CHECK2-NEXT:    [[ARRAYIDX14:%.*]] = getelementptr inbounds float, ptr [[TMP21]], i64 [[IDXPROM13]]
// CHECK2-NEXT:    store float [[MUL12]], ptr [[ARRAYIDX14]], align 4
// CHECK2-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK2:       omp.body.continue:
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK2:       omp.inner.for.inc:
// CHECK2-NEXT:    [[TMP23:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[ADD15:%.*]] = add nsw i32 [[TMP23]], 1
// CHECK2-NEXT:    store i32 [[ADD15]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK2:       omp.inner.for.end:
// CHECK2-NEXT:    br label [[OMP_LOOP_EXIT:%.*]]
// CHECK2:       omp.loop.exit:
// CHECK2-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP5]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z18static_not_chunkedPfS_S_S_
// CHECK2-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z18static_not_chunkedPfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z18static_not_chunkedPfS_S_S_.omp_outlined
// CHECK2-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    store i32 4571423, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[I]], align 4
// CHECK2-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB1]], i32 [[TMP5]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1)
// CHECK2-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP6]], 4571423
// CHECK2-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK2:       cond.true:
// CHECK2-NEXT:    br label [[COND_END:%.*]]
// CHECK2:       cond.false:
// CHECK2-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    br label [[COND_END]]
// CHECK2:       cond.end:
// CHECK2-NEXT:    [[COND:%.*]] = phi i32 [ 4571423, [[COND_TRUE]] ], [ [[TMP7]], [[COND_FALSE]] ]
// CHECK2-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    store i32 [[TMP8]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK2:       omp.inner.for.cond:
// CHECK2-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[CMP6:%.*]] = icmp sle i32 [[TMP9]], [[TMP10]]
// CHECK2-NEXT:    br i1 [[CMP6]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK2:       omp.inner.for.body:
// CHECK2-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP11]], 7
// CHECK2-NEXT:    [[SUB:%.*]] = sub nsw i32 32000000, [[MUL]]
// CHECK2-NEXT:    store i32 [[SUB]], ptr [[I]], align 4
// CHECK2-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[TMP1]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP13]] to i64
// CHECK2-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[TMP12]], i64 [[IDXPROM]]
// CHECK2-NEXT:    [[TMP14:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[TMP2]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP16:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM7:%.*]] = sext i32 [[TMP16]] to i64
// CHECK2-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[TMP15]], i64 [[IDXPROM7]]
// CHECK2-NEXT:    [[TMP17:%.*]] = load float, ptr [[ARRAYIDX8]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL9:%.*]] = fmul float [[TMP14]], [[TMP17]]
// CHECK2-NEXT:    [[TMP18:%.*]] = load ptr, ptr [[TMP3]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP19:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM10:%.*]] = sext i32 [[TMP19]] to i64
// CHECK2-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds float, ptr [[TMP18]], i64 [[IDXPROM10]]
// CHECK2-NEXT:    [[TMP20:%.*]] = load float, ptr [[ARRAYIDX11]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL12:%.*]] = fmul float [[MUL9]], [[TMP20]]
// CHECK2-NEXT:    [[TMP21:%.*]] = load ptr, ptr [[TMP0]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP22:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM13:%.*]] = sext i32 [[TMP22]] to i64
// CHECK2-NEXT:    [[ARRAYIDX14:%.*]] = getelementptr inbounds float, ptr [[TMP21]], i64 [[IDXPROM13]]
// CHECK2-NEXT:    store float [[MUL12]], ptr [[ARRAYIDX14]], align 4
// CHECK2-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK2:       omp.body.continue:
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK2:       omp.inner.for.inc:
// CHECK2-NEXT:    [[TMP23:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP23]], 1
// CHECK2-NEXT:    store i32 [[ADD]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK2:       omp.inner.for.end:
// CHECK2-NEXT:    br label [[OMP_LOOP_EXIT:%.*]]
// CHECK2:       omp.loop.exit:
// CHECK2-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP5]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z14static_chunkedPfS_S_S_
// CHECK2-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z14static_chunkedPfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z14static_chunkedPfS_S_S_.omp_outlined
// CHECK2-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    store i32 16908288, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[I]], align 4
// CHECK2-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void @__kmpc_for_static_init_4u(ptr @[[GLOB1]], i32 [[TMP5]], i32 33, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 5)
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK2:       omp.dispatch.cond:
// CHECK2-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[TMP6]], 16908288
// CHECK2-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK2:       cond.true:
// CHECK2-NEXT:    br label [[COND_END:%.*]]
// CHECK2:       cond.false:
// CHECK2-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    br label [[COND_END]]
// CHECK2:       cond.end:
// CHECK2-NEXT:    [[COND:%.*]] = phi i32 [ 16908288, [[COND_TRUE]] ], [ [[TMP7]], [[COND_FALSE]] ]
// CHECK2-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    store i32 [[TMP8]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[CMP6:%.*]] = icmp ule i32 [[TMP9]], [[TMP10]]
// CHECK2-NEXT:    br i1 [[CMP6]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK2:       omp.dispatch.body:
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK2:       omp.inner.for.cond:
// CHECK2-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[CMP7:%.*]] = icmp ule i32 [[TMP11]], [[TMP12]]
// CHECK2-NEXT:    br i1 [[CMP7]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK2:       omp.inner.for.body:
// CHECK2-NEXT:    [[TMP13:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[MUL:%.*]] = mul i32 [[TMP13]], 127
// CHECK2-NEXT:    [[ADD:%.*]] = add i32 131071, [[MUL]]
// CHECK2-NEXT:    store i32 [[ADD]], ptr [[I]], align 4
// CHECK2-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP1]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP15:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM:%.*]] = zext i32 [[TMP15]] to i64
// CHECK2-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP14]], i64 [[IDXPROM]]
// CHECK2-NEXT:    [[TMP16:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP2]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP18:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM8:%.*]] = zext i32 [[TMP18]] to i64
// CHECK2-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds nuw float, ptr [[TMP17]], i64 [[IDXPROM8]]
// CHECK2-NEXT:    [[TMP19:%.*]] = load float, ptr [[ARRAYIDX9]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL10:%.*]] = fmul float [[TMP16]], [[TMP19]]
// CHECK2-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[TMP3]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP21:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM11:%.*]] = zext i32 [[TMP21]] to i64
// CHECK2-NEXT:    [[ARRAYIDX12:%.*]] = getelementptr inbounds nuw float, ptr [[TMP20]], i64 [[IDXPROM11]]
// CHECK2-NEXT:    [[TMP22:%.*]] = load float, ptr [[ARRAYIDX12]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL13:%.*]] = fmul float [[MUL10]], [[TMP22]]
// CHECK2-NEXT:    [[TMP23:%.*]] = load ptr, ptr [[TMP0]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP24:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM14:%.*]] = zext i32 [[TMP24]] to i64
// CHECK2-NEXT:    [[ARRAYIDX15:%.*]] = getelementptr inbounds nuw float, ptr [[TMP23]], i64 [[IDXPROM14]]
// CHECK2-NEXT:    store float [[MUL13]], ptr [[ARRAYIDX15]], align 4
// CHECK2-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK2:       omp.body.continue:
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK2:       omp.inner.for.inc:
// CHECK2-NEXT:    [[TMP25:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[ADD16:%.*]] = add i32 [[TMP25]], 1
// CHECK2-NEXT:    store i32 [[ADD16]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK2:       omp.inner.for.end:
// CHECK2-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK2:       omp.dispatch.inc:
// CHECK2-NEXT:    [[TMP26:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    [[TMP27:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    [[ADD17:%.*]] = add i32 [[TMP26]], [[TMP27]]
// CHECK2-NEXT:    store i32 [[ADD17]], ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    [[TMP28:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[TMP29:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    [[ADD18:%.*]] = add i32 [[TMP28]], [[TMP29]]
// CHECK2-NEXT:    store i32 [[ADD18]], ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK2:       omp.dispatch.end:
// CHECK2-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP5]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z8dynamic1PfS_S_S_
// CHECK2-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z8dynamic1PfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z8dynamic1PfS_S_S_.omp_outlined
// CHECK2-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[TMP:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[I:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    store i64 16908287, ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK2-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON5]], ptr [[I]], align 8
// CHECK2-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void @__kmpc_dispatch_init_8u(ptr @[[GLOB2]], i32 [[TMP5]], i32 35, i64 0, i64 16908287, i64 1, i64 1)
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK2:       omp.dispatch.cond:
// CHECK2-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_dispatch_next_8u(ptr @[[GLOB2]], i32 [[TMP5]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]])
// CHECK2-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP6]], 0
// CHECK2-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK2:       omp.dispatch.body:
// CHECK2-NEXT:    [[TMP7:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    store i64 [[TMP7]], ptr [[DOTOMP_IV]], align 8
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK2:       omp.inner.for.cond:
// CHECK2-NEXT:    [[TMP8:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP7:![0-9]+]]
// CHECK2-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK2-NEXT:    [[ADD:%.*]] = add i64 [[TMP9]], 1
// CHECK2-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TMP8]], [[ADD]]
// CHECK2-NEXT:    br i1 [[CMP]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK2:       omp.inner.for.body:
// CHECK2-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK2-NEXT:    [[MUL:%.*]] = mul i64 [[TMP10]], 127
// CHECK2-NEXT:    [[ADD6:%.*]] = add i64 131071, [[MUL]]
// CHECK2-NEXT:    store i64 [[ADD6]], ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK2-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[TMP1]], align 8, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP12:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK2-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP11]], i64 [[TMP12]]
// CHECK2-NEXT:    [[TMP13:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP2]], align 8, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP15:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK2-NEXT:    [[ARRAYIDX7:%.*]] = getelementptr inbounds nuw float, ptr [[TMP14]], i64 [[TMP15]]
// CHECK2-NEXT:    [[TMP16:%.*]] = load float, ptr [[ARRAYIDX7]], align 4, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL8:%.*]] = fmul float [[TMP13]], [[TMP16]]
// CHECK2-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP3]], align 8, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP18:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK2-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds nuw float, ptr [[TMP17]], i64 [[TMP18]]
// CHECK2-NEXT:    [[TMP19:%.*]] = load float, ptr [[ARRAYIDX9]], align 4, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL10:%.*]] = fmul float [[MUL8]], [[TMP19]]
// CHECK2-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[TMP0]], align 8, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP21:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK2-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds nuw float, ptr [[TMP20]], i64 [[TMP21]]
// CHECK2-NEXT:    store float [[MUL10]], ptr [[ARRAYIDX11]], align 4, !llvm.access.group [[ACC_GRP7]]
// CHECK2-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK2:       omp.body.continue:
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK2:       omp.inner.for.inc:
// CHECK2-NEXT:    [[TMP22:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK2-NEXT:    [[ADD12:%.*]] = add i64 [[TMP22]], 1
// CHECK2-NEXT:    store i64 [[ADD12]], ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND]], !llvm.loop [[LOOP8:![0-9]+]]
// CHECK2:       omp.inner.for.end:
// CHECK2-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK2:       omp.dispatch.inc:
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK2:       omp.dispatch.end:
// CHECK2-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB2]], i32 [[TMP5]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z7guided7PfS_S_S_
// CHECK2-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z7guided7PfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z7guided7PfS_S_S_.omp_outlined
// CHECK2-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[TMP:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[I:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    store i64 16908287, ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK2-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON5]], ptr [[I]], align 8
// CHECK2-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void @__kmpc_dispatch_init_8u(ptr @[[GLOB2]], i32 [[TMP5]], i32 36, i64 0, i64 16908287, i64 1, i64 7)
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK2:       omp.dispatch.cond:
// CHECK2-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_dispatch_next_8u(ptr @[[GLOB2]], i32 [[TMP5]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]])
// CHECK2-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP6]], 0
// CHECK2-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK2:       omp.dispatch.body:
// CHECK2-NEXT:    [[TMP7:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    store i64 [[TMP7]], ptr [[DOTOMP_IV]], align 8
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK2:       omp.inner.for.cond:
// CHECK2-NEXT:    [[TMP8:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP10:![0-9]+]]
// CHECK2-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK2-NEXT:    [[ADD:%.*]] = add i64 [[TMP9]], 1
// CHECK2-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TMP8]], [[ADD]]
// CHECK2-NEXT:    br i1 [[CMP]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK2:       omp.inner.for.body:
// CHECK2-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK2-NEXT:    [[MUL:%.*]] = mul i64 [[TMP10]], 127
// CHECK2-NEXT:    [[ADD6:%.*]] = add i64 131071, [[MUL]]
// CHECK2-NEXT:    store i64 [[ADD6]], ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK2-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[TMP1]], align 8, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP12:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK2-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP11]], i64 [[TMP12]]
// CHECK2-NEXT:    [[TMP13:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP2]], align 8, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP15:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK2-NEXT:    [[ARRAYIDX7:%.*]] = getelementptr inbounds nuw float, ptr [[TMP14]], i64 [[TMP15]]
// CHECK2-NEXT:    [[TMP16:%.*]] = load float, ptr [[ARRAYIDX7]], align 4, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL8:%.*]] = fmul float [[TMP13]], [[TMP16]]
// CHECK2-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP3]], align 8, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP18:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK2-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds nuw float, ptr [[TMP17]], i64 [[TMP18]]
// CHECK2-NEXT:    [[TMP19:%.*]] = load float, ptr [[ARRAYIDX9]], align 4, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL10:%.*]] = fmul float [[MUL8]], [[TMP19]]
// CHECK2-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[TMP0]], align 8, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP21:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK2-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds nuw float, ptr [[TMP20]], i64 [[TMP21]]
// CHECK2-NEXT:    store float [[MUL10]], ptr [[ARRAYIDX11]], align 4, !llvm.access.group [[ACC_GRP10]]
// CHECK2-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK2:       omp.body.continue:
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK2:       omp.inner.for.inc:
// CHECK2-NEXT:    [[TMP22:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK2-NEXT:    [[ADD12:%.*]] = add i64 [[TMP22]], 1
// CHECK2-NEXT:    store i64 [[ADD12]], ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND]], !llvm.loop [[LOOP11:![0-9]+]]
// CHECK2:       omp.inner.for.end:
// CHECK2-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK2:       omp.dispatch.inc:
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK2:       omp.dispatch.end:
// CHECK2-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB2]], i32 [[TMP5]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z9test_autoPfS_S_S_
// CHECK2-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[Y:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON]], ptr [[X]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[X]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[Y]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[Y]], align 4
// CHECK2-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 5, ptr @_Z9test_autoPfS_S_S_.omp_outlined, ptr [[Y]], ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z9test_autoPfS_S_S_.omp_outlined
// CHECK2-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 4 dereferenceable(4) [[Y:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[Y_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[TMP:%.*]] = alloca i8, align 1
// CHECK2-NEXT:    [[_TMP1:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTCAPTURE_EXPR_:%.*]] = alloca i8, align 1
// CHECK2-NEXT:    [[DOTCAPTURE_EXPR_3:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[I:%.*]] = alloca i8, align 1
// CHECK2-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[I15:%.*]] = alloca i8, align 1
// CHECK2-NEXT:    [[X17:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[Y]], ptr [[Y_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[Y_ADDR]], align 8, !nonnull [[META3]], !align [[META13:![0-9]+]]
// CHECK2-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i8 poison
// CHECK2-NEXT:    store i8 [[FREEZE_POISON2]], ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK2-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP0]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[CONV:%.*]] = trunc i32 [[TMP5]] to i8
// CHECK2-NEXT:    store i8 [[CONV]], ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK2-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON4]], ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK2-NEXT:    [[TMP6:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK2-NEXT:    [[CONV5:%.*]] = sext i8 [[TMP6]] to i32
// CHECK2-NEXT:    [[SUB:%.*]] = sub i32 57, [[CONV5]]
// CHECK2-NEXT:    [[ADD:%.*]] = add i32 [[SUB]], 1
// CHECK2-NEXT:    [[DIV:%.*]] = udiv i32 [[ADD]], 1
// CHECK2-NEXT:    [[CONV6:%.*]] = zext i32 [[DIV]] to i64
// CHECK2-NEXT:    [[MUL:%.*]] = mul nsw i64 [[CONV6]], 11
// CHECK2-NEXT:    [[SUB7:%.*]] = sub nsw i64 [[MUL]], 1
// CHECK2-NEXT:    store i64 [[SUB7]], ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON8:%.*]] = freeze i8 poison
// CHECK2-NEXT:    store i8 [[FREEZE_POISON8]], ptr [[I]], align 1
// CHECK2-NEXT:    [[FREEZE_POISON9:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON9]], ptr [[X]], align 4
// CHECK2-NEXT:    [[TMP7:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK2-NEXT:    store i8 [[TMP7]], ptr [[I]], align 1
// CHECK2-NEXT:    store i32 11, ptr [[X]], align 4
// CHECK2-NEXT:    [[TMP8:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK2-NEXT:    [[CONV10:%.*]] = sext i8 [[TMP8]] to i32
// CHECK2-NEXT:    [[CMP:%.*]] = icmp sle i32 [[CONV10]], 57
// CHECK2-NEXT:    br i1 [[CMP]], label [[OMP_PRECOND_THEN:%.*]], label [[OMP_PRECOND_END:%.*]]
// CHECK2:       omp.precond.then:
// CHECK2-NEXT:    [[FREEZE_POISON11:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON11]], ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON12:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON12]], ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK2-NEXT:    store i64 [[TMP9]], ptr [[DOTOMP_UB]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON13:%.*]] = freeze i64 poison
// CHECK2-NEXT:    store i64 [[FREEZE_POISON13]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK2-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON14:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON14]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON16:%.*]] = freeze i8 poison
// CHECK2-NEXT:    store i8 [[FREEZE_POISON16]], ptr [[I15]], align 1
// CHECK2-NEXT:    [[FREEZE_POISON18:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON18]], ptr [[X17]], align 4
// CHECK2-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK2-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    [[TMP12:%.*]] = load i32, ptr [[TMP11]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void @__kmpc_dispatch_init_8(ptr @[[GLOB2]], i32 [[TMP12]], i32 38, i64 0, i64 [[TMP10]], i64 1, i64 1)
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK2:       omp.dispatch.cond:
// CHECK2-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    [[TMP14:%.*]] = load i32, ptr [[TMP13]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP15:%.*]] = call i32 @__kmpc_dispatch_next_8(ptr @[[GLOB2]], i32 [[TMP14]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]])
// CHECK2-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP15]], 0
// CHECK2-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK2:       omp.dispatch.body:
// CHECK2-NEXT:    [[TMP16:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK2-NEXT:    store i64 [[TMP16]], ptr [[DOTOMP_IV]], align 8
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK2:       omp.inner.for.cond:
// CHECK2-NEXT:    [[TMP17:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14:![0-9]+]]
// CHECK2-NEXT:    [[TMP18:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    [[CMP19:%.*]] = icmp sle i64 [[TMP17]], [[TMP18]]
// CHECK2-NEXT:    br i1 [[CMP19]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK2:       omp.inner.for.body:
// CHECK2-NEXT:    [[TMP19:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    [[CONV20:%.*]] = sext i8 [[TMP19]] to i64
// CHECK2-NEXT:    [[TMP20:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    [[DIV21:%.*]] = sdiv i64 [[TMP20]], 11
// CHECK2-NEXT:    [[MUL22:%.*]] = mul nsw i64 [[DIV21]], 1
// CHECK2-NEXT:    [[ADD23:%.*]] = add nsw i64 [[CONV20]], [[MUL22]]
// CHECK2-NEXT:    [[CONV24:%.*]] = trunc i64 [[ADD23]] to i8
// CHECK2-NEXT:    store i8 [[CONV24]], ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    [[TMP21:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    [[TMP22:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    [[DIV25:%.*]] = sdiv i64 [[TMP22]], 11
// CHECK2-NEXT:    [[MUL26:%.*]] = mul nsw i64 [[DIV25]], 11
// CHECK2-NEXT:    [[SUB27:%.*]] = sub nsw i64 [[TMP21]], [[MUL26]]
// CHECK2-NEXT:    [[MUL28:%.*]] = mul nsw i64 [[SUB27]], 1
// CHECK2-NEXT:    [[SUB29:%.*]] = sub nsw i64 11, [[MUL28]]
// CHECK2-NEXT:    [[CONV30:%.*]] = trunc i64 [[SUB29]] to i32
// CHECK2-NEXT:    store i32 [[CONV30]], ptr [[X17]], align 4, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    [[TMP23:%.*]] = load ptr, ptr [[TMP2]], align 8, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP24:%.*]] = load i8, ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    [[IDXPROM:%.*]] = sext i8 [[TMP24]] to i64
// CHECK2-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[TMP23]], i64 [[IDXPROM]]
// CHECK2-NEXT:    [[TMP25:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP26:%.*]] = load ptr, ptr [[TMP3]], align 8, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP27:%.*]] = load i8, ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    [[IDXPROM31:%.*]] = sext i8 [[TMP27]] to i64
// CHECK2-NEXT:    [[ARRAYIDX32:%.*]] = getelementptr inbounds float, ptr [[TMP26]], i64 [[IDXPROM31]]
// CHECK2-NEXT:    [[TMP28:%.*]] = load float, ptr [[ARRAYIDX32]], align 4, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL33:%.*]] = fmul float [[TMP25]], [[TMP28]]
// CHECK2-NEXT:    [[TMP29:%.*]] = load ptr, ptr [[TMP4]], align 8, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP30:%.*]] = load i8, ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    [[IDXPROM34:%.*]] = sext i8 [[TMP30]] to i64
// CHECK2-NEXT:    [[ARRAYIDX35:%.*]] = getelementptr inbounds float, ptr [[TMP29]], i64 [[IDXPROM34]]
// CHECK2-NEXT:    [[TMP31:%.*]] = load float, ptr [[ARRAYIDX35]], align 4, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL36:%.*]] = fmul float [[MUL33]], [[TMP31]]
// CHECK2-NEXT:    [[TMP32:%.*]] = load ptr, ptr [[TMP1]], align 8, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP33:%.*]] = load i8, ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    [[IDXPROM37:%.*]] = sext i8 [[TMP33]] to i64
// CHECK2-NEXT:    [[ARRAYIDX38:%.*]] = getelementptr inbounds float, ptr [[TMP32]], i64 [[IDXPROM37]]
// CHECK2-NEXT:    store float [[MUL36]], ptr [[ARRAYIDX38]], align 4, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK2:       omp.body.continue:
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK2:       omp.inner.for.inc:
// CHECK2-NEXT:    [[TMP34:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    [[ADD39:%.*]] = add nsw i64 [[TMP34]], 1
// CHECK2-NEXT:    store i64 [[ADD39]], ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND]], !llvm.loop [[LOOP15:![0-9]+]]
// CHECK2:       omp.inner.for.end:
// CHECK2-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK2:       omp.dispatch.inc:
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK2:       omp.dispatch.end:
// CHECK2-NEXT:    [[TMP35:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    [[TMP36:%.*]] = load i32, ptr [[TMP35]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB2]], i32 [[TMP36]])
// CHECK2-NEXT:    br label [[OMP_PRECOND_END]]
// CHECK2:       omp.precond.end:
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z7runtimePfS_S_S_
// CHECK2-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON]], ptr [[X]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[X]], align 4
// CHECK2-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z7runtimePfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z7runtimePfS_S_S_.omp_outlined
// CHECK2-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[TMP:%.*]] = alloca i8, align 1
// CHECK2-NEXT:    [[_TMP1:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[I:%.*]] = alloca i8, align 1
// CHECK2-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK2-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK2-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    store i32 199, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON6:%.*]] = freeze i8 poison
// CHECK2-NEXT:    store i8 [[FREEZE_POISON6]], ptr [[I]], align 1
// CHECK2-NEXT:    [[FREEZE_POISON7:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON7]], ptr [[X]], align 4
// CHECK2-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void @__kmpc_dispatch_init_4(ptr @[[GLOB2]], i32 [[TMP5]], i32 37, i32 0, i32 199, i32 1, i32 1)
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK2:       omp.dispatch.cond:
// CHECK2-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_dispatch_next_4(ptr @[[GLOB2]], i32 [[TMP5]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]])
// CHECK2-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP6]], 0
// CHECK2-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK2:       omp.dispatch.body:
// CHECK2-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    store i32 [[TMP7]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK2:       omp.inner.for.cond:
// CHECK2-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17:![0-9]+]]
// CHECK2-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK2-NEXT:    [[CMP:%.*]] = icmp sle i32 [[TMP8]], [[TMP9]]
// CHECK2-NEXT:    br i1 [[CMP]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK2:       omp.inner.for.body:
// CHECK2-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK2-NEXT:    [[DIV:%.*]] = sdiv i32 [[TMP10]], 20
// CHECK2-NEXT:    [[MUL:%.*]] = mul nsw i32 [[DIV]], 1
// CHECK2-NEXT:    [[ADD:%.*]] = add nsw i32 48, [[MUL]]
// CHECK2-NEXT:    [[CONV:%.*]] = trunc i32 [[ADD]] to i8
// CHECK2-NEXT:    store i8 [[CONV]], ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK2-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK2-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK2-NEXT:    [[DIV8:%.*]] = sdiv i32 [[TMP12]], 20
// CHECK2-NEXT:    [[MUL9:%.*]] = mul nsw i32 [[DIV8]], 20
// CHECK2-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP11]], [[MUL9]]
// CHECK2-NEXT:    [[MUL10:%.*]] = mul nsw i32 [[SUB]], 1
// CHECK2-NEXT:    [[ADD11:%.*]] = add nsw i32 -10, [[MUL10]]
// CHECK2-NEXT:    store i32 [[ADD11]], ptr [[X]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK2-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[TMP1]], align 8, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP14:%.*]] = load i8, ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK2-NEXT:    [[IDXPROM:%.*]] = zext i8 [[TMP14]] to i64
// CHECK2-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP13]], i64 [[IDXPROM]]
// CHECK2-NEXT:    [[TMP15:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[TMP2]], align 8, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP17:%.*]] = load i8, ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK2-NEXT:    [[IDXPROM12:%.*]] = zext i8 [[TMP17]] to i64
// CHECK2-NEXT:    [[ARRAYIDX13:%.*]] = getelementptr inbounds nuw float, ptr [[TMP16]], i64 [[IDXPROM12]]
// CHECK2-NEXT:    [[TMP18:%.*]] = load float, ptr [[ARRAYIDX13]], align 4, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL14:%.*]] = fmul float [[TMP15]], [[TMP18]]
// CHECK2-NEXT:    [[TMP19:%.*]] = load ptr, ptr [[TMP3]], align 8, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP20:%.*]] = load i8, ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK2-NEXT:    [[IDXPROM15:%.*]] = zext i8 [[TMP20]] to i64
// CHECK2-NEXT:    [[ARRAYIDX16:%.*]] = getelementptr inbounds nuw float, ptr [[TMP19]], i64 [[IDXPROM15]]
// CHECK2-NEXT:    [[TMP21:%.*]] = load float, ptr [[ARRAYIDX16]], align 4, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[MUL17:%.*]] = fmul float [[MUL14]], [[TMP21]]
// CHECK2-NEXT:    [[TMP22:%.*]] = load ptr, ptr [[TMP0]], align 8, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP23:%.*]] = load i8, ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK2-NEXT:    [[IDXPROM18:%.*]] = zext i8 [[TMP23]] to i64
// CHECK2-NEXT:    [[ARRAYIDX19:%.*]] = getelementptr inbounds nuw float, ptr [[TMP22]], i64 [[IDXPROM18]]
// CHECK2-NEXT:    store float [[MUL17]], ptr [[ARRAYIDX19]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK2-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK2:       omp.body.continue:
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK2:       omp.inner.for.inc:
// CHECK2-NEXT:    [[TMP24:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK2-NEXT:    [[ADD20:%.*]] = add nsw i32 [[TMP24]], 1
// CHECK2-NEXT:    store i32 [[ADD20]], ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND]], !llvm.loop [[LOOP18:![0-9]+]]
// CHECK2:       omp.inner.for.end:
// CHECK2-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK2:       omp.dispatch.inc:
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK2:       omp.dispatch.end:
// CHECK2-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB2]], i32 [[TMP5]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z3foov
// CHECK2-SAME: () #[[ATTR3:[0-9]+]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    call void @_Z8mayThrowv()
// CHECK2-NEXT:    ret i32 0
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z12parallel_forPfi
// CHECK2-SAME: (ptr noundef [[A:%.*]], i32 noundef [[N:%.*]]) #[[ATTR0]] {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[N_ADDR:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[SAVED_STACK:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[N_CASTED:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store i32 [[N]], ptr [[N_ADDR]], align 4
// CHECK2-NEXT:    [[TMP0:%.*]] = load i32, ptr [[N_ADDR]], align 4
// CHECK2-NEXT:    [[TMP1:%.*]] = zext i32 [[TMP0]] to i64
// CHECK2-NEXT:    [[TMP2:%.*]] = call ptr @llvm.stacksave.p0()
// CHECK2-NEXT:    store ptr [[TMP2]], ptr [[SAVED_STACK]], align 8
// CHECK2-NEXT:    [[VLA:%.*]] = alloca float, i64 [[TMP1]], align 16
// CHECK2-NEXT:    store i64 [[TMP1]], ptr [[__VLA_EXPR0]], align 8
// CHECK2-NEXT:    [[TMP3:%.*]] = load i32, ptr [[N_ADDR]], align 4
// CHECK2-NEXT:    store i32 [[TMP3]], ptr [[N_CASTED]], align 4
// CHECK2-NEXT:    [[TMP4:%.*]] = load i64, ptr [[N_CASTED]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 3, ptr @_Z12parallel_forPfi.omp_outlined, ptr [[A_ADDR]], i64 [[TMP1]], i64 [[TMP4]])
// CHECK2-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[SAVED_STACK]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void @llvm.stackrestore.p0(ptr [[TMP5]])
// CHECK2-NEXT:    ret void
//
//
// CHECK2-LABEL: define {{[^@]+}}@_Z12parallel_forPfi.omp_outlined
// CHECK2-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], i64 noundef [[VLA:%.*]], i64 noundef [[N:%.*]]) #[[ATTR1]] personality ptr @__gxx_personality_v0 {
// CHECK2-NEXT:  entry:
// CHECK2-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[VLA_ADDR:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[N_ADDR:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    [[SAVED_STACK:%.*]] = alloca ptr, align 8
// CHECK2-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i64, align 8
// CHECK2-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK2-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK2-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK2-NEXT:    store i64 [[VLA]], ptr [[VLA_ADDR]], align 8
// CHECK2-NEXT:    store i64 [[N]], ptr [[N_ADDR]], align 8
// CHECK2-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK2-NEXT:    [[TMP1:%.*]] = load i64, ptr [[VLA_ADDR]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    store i32 16908288, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK2-NEXT:    [[TMP2:%.*]] = call ptr @llvm.stacksave.p0()
// CHECK2-NEXT:    store ptr [[TMP2]], ptr [[SAVED_STACK]], align 8
// CHECK2-NEXT:    [[VLA5:%.*]] = alloca float, i64 [[TMP1]], align 16
// CHECK2-NEXT:    store i64 [[TMP1]], ptr [[__VLA_EXPR0]], align 8
// CHECK2-NEXT:    [[FREEZE_POISON6:%.*]] = freeze i32 poison
// CHECK2-NEXT:    store i32 [[FREEZE_POISON6]], ptr [[I]], align 4
// CHECK2-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK2-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP3]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void @__kmpc_for_static_init_4u(ptr @[[GLOB1]], i32 [[TMP4]], i32 33, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 5)
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK2:       omp.dispatch.cond:
// CHECK2-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[TMP5]], 16908288
// CHECK2-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK2:       cond.true:
// CHECK2-NEXT:    br label [[COND_END:%.*]]
// CHECK2:       cond.false:
// CHECK2-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    br label [[COND_END]]
// CHECK2:       cond.end:
// CHECK2-NEXT:    [[COND:%.*]] = phi i32 [ 16908288, [[COND_TRUE]] ], [ [[TMP6]], [[COND_FALSE]] ]
// CHECK2-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    store i32 [[TMP7]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[CMP7:%.*]] = icmp ule i32 [[TMP8]], [[TMP9]]
// CHECK2-NEXT:    br i1 [[CMP7]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_CLEANUP:%.*]]
// CHECK2:       omp.dispatch.cleanup:
// CHECK2-NEXT:    br label [[OMP_DISPATCH_END:%.*]]
// CHECK2:       omp.dispatch.body:
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK2:       omp.inner.for.cond:
// CHECK2-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[CMP8:%.*]] = icmp ule i32 [[TMP10]], [[TMP11]]
// CHECK2-NEXT:    br i1 [[CMP8]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_COND_CLEANUP:%.*]]
// CHECK2:       omp.inner.for.cond.cleanup:
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_END:%.*]]
// CHECK2:       omp.inner.for.body:
// CHECK2-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[MUL:%.*]] = mul i32 [[TMP12]], 127
// CHECK2-NEXT:    [[ADD:%.*]] = add i32 131071, [[MUL]]
// CHECK2-NEXT:    store i32 [[ADD]], ptr [[I]], align 4
// CHECK2-NEXT:    [[CALL:%.*]] = invoke noundef i32 @_Z3foov()
// CHECK2-NEXT:            to label [[INVOKE_CONT:%.*]] unwind label [[TERMINATE_LPAD:%.*]]
// CHECK2:       invoke.cont:
// CHECK2-NEXT:    [[CONV:%.*]] = sitofp i32 [[CALL]] to float
// CHECK2-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM:%.*]] = zext i32 [[TMP13]] to i64
// CHECK2-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[VLA5]], i64 [[IDXPROM]]
// CHECK2-NEXT:    [[TMP14:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[ADD9:%.*]] = fadd float [[CONV]], [[TMP14]]
// CHECK2-NEXT:    [[TMP15:%.*]] = load i32, ptr [[N_ADDR]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[CONV10:%.*]] = sitofp i32 [[TMP15]] to float
// CHECK2-NEXT:    [[ADD11:%.*]] = fadd float [[ADD9]], [[CONV10]]
// CHECK2-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[TMP0]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[TMP17:%.*]] = load i32, ptr [[I]], align 4
// CHECK2-NEXT:    [[IDXPROM12:%.*]] = zext i32 [[TMP17]] to i64
// CHECK2-NEXT:    [[ARRAYIDX13:%.*]] = getelementptr inbounds nuw float, ptr [[TMP16]], i64 [[IDXPROM12]]
// CHECK2-NEXT:    [[TMP18:%.*]] = load float, ptr [[ARRAYIDX13]], align 4, !freeze_bits [[META3]]
// CHECK2-NEXT:    [[ADD14:%.*]] = fadd float [[TMP18]], [[ADD11]]
// CHECK2-NEXT:    store float [[ADD14]], ptr [[ARRAYIDX13]], align 4
// CHECK2-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK2:       omp.body.continue:
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK2:       omp.inner.for.inc:
// CHECK2-NEXT:    [[TMP19:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    [[ADD15:%.*]] = add i32 [[TMP19]], 1
// CHECK2-NEXT:    store i32 [[ADD15]], ptr [[DOTOMP_IV]], align 4
// CHECK2-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK2:       omp.inner.for.end:
// CHECK2-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK2:       omp.dispatch.inc:
// CHECK2-NEXT:    [[TMP20:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    [[TMP21:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    [[ADD16:%.*]] = add i32 [[TMP20]], [[TMP21]]
// CHECK2-NEXT:    store i32 [[ADD16]], ptr [[DOTOMP_LB]], align 4
// CHECK2-NEXT:    [[TMP22:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    [[TMP23:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4
// CHECK2-NEXT:    [[ADD17:%.*]] = add i32 [[TMP22]], [[TMP23]]
// CHECK2-NEXT:    store i32 [[ADD17]], ptr [[DOTOMP_UB]], align 4
// CHECK2-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK2:       omp.dispatch.end:
// CHECK2-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP4]])
// CHECK2-NEXT:    [[TMP24:%.*]] = load ptr, ptr [[SAVED_STACK]], align 8, !freeze_bits [[META3]]
// CHECK2-NEXT:    call void @llvm.stackrestore.p0(ptr [[TMP24]])
// CHECK2-NEXT:    ret void
// CHECK2:       terminate.lpad:
// CHECK2-NEXT:    [[TMP25:%.*]] = landingpad { ptr, i32 }
// CHECK2-NEXT:            catch ptr null
// CHECK2-NEXT:    [[TMP26:%.*]] = extractvalue { ptr, i32 } [[TMP25]], 0
// CHECK2-NEXT:    call void @__clang_call_terminate(ptr [[TMP26]]) #[[ATTR7:[0-9]+]]
// CHECK2-NEXT:    unreachable
//
//
// CHECK2-LABEL: define {{[^@]+}}@__clang_call_terminate
// CHECK2-SAME: (ptr noundef [[TMP0:%.*]]) #[[ATTR6:[0-9]+]] comdat {
// CHECK2-NEXT:    [[TMP2:%.*]] = call ptr @__cxa_begin_catch(ptr [[TMP0]]) #[[ATTR2:[0-9]+]]
// CHECK2-NEXT:    call void @_ZSt9terminatev() #[[ATTR7]]
// CHECK2-NEXT:    unreachable
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z17with_var_schedulev
// CHECK5-SAME: () #[[ATTR0:[0-9]+]] !dbg [[DBG6:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[A:%.*]] = alloca double, align 8
// CHECK5-NEXT:    [[DOTCAPTURE_EXPR_:%.*]] = alloca i8, align 1
// CHECK5-NEXT:    [[DOTCAPTURE_EXPR__CASTED:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[FREEZE_POISON:%.*]] = freeze double poison, !dbg [[DBG10:![0-9]+]]
// CHECK5-NEXT:    store double [[FREEZE_POISON]], ptr [[A]], align 8, !dbg [[DBG10]]
// CHECK5-NEXT:    store double 5.000000e+00, ptr [[A]], align 8, !dbg [[DBG10]]
// CHECK5-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i8 poison, !dbg [[DBG11:![0-9]+]]
// CHECK5-NEXT:    store i8 [[FREEZE_POISON1]], ptr [[DOTCAPTURE_EXPR_]], align 1, !dbg [[DBG11]]
// CHECK5-NEXT:    [[TMP0:%.*]] = load double, ptr [[A]], align 8, !dbg [[DBG11]]
// CHECK5-NEXT:    [[CONV:%.*]] = fptosi double [[TMP0]] to i8, !dbg [[DBG11]]
// CHECK5-NEXT:    store i8 [[CONV]], ptr [[DOTCAPTURE_EXPR_]], align 1, !dbg [[DBG11]]
// CHECK5-NEXT:    [[TMP1:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1, !dbg [[DBG11]]
// CHECK5-NEXT:    store i8 [[TMP1]], ptr [[DOTCAPTURE_EXPR__CASTED]], align 1, !dbg [[DBG11]]
// CHECK5-NEXT:    [[TMP2:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR__CASTED]], align 8, !dbg [[DBG11]], !freeze_bits [[META9:![0-9]+]]
// CHECK5-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB4:[0-9]+]], i32 1, ptr @_Z17with_var_schedulev.omp_outlined, i64 [[TMP2]]), !dbg [[DBG11]]
// CHECK5-NEXT:    ret void, !dbg [[DBG12:![0-9]+]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z17with_var_schedulev.omp_outlined
// CHECK5-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], i64 noundef [[DOTCAPTURE_EXPR_:%.*]]) #[[ATTR1:[0-9]+]] !dbg [[DBG13:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTCAPTURE_EXPR__ADDR:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[TMP:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTCAPTURE_EXPR_1:%.*]] = alloca double, align 8
// CHECK5-NEXT:    [[DOTCAPTURE_EXPR_3:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[I:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[A:%.*]] = alloca double, align 8
// CHECK5-NEXT:    [[I12:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK5-NEXT:    store i64 [[DOTCAPTURE_EXPR_]], ptr [[DOTCAPTURE_EXPR__ADDR]], align 8
// CHECK5-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison, !dbg [[DBG14:![0-9]+]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8, !dbg [[DBG14]]
// CHECK5-NEXT:    [[FREEZE_POISON2:%.*]] = freeze double poison, !dbg [[DBG14]]
// CHECK5-NEXT:    store double [[FREEZE_POISON2]], ptr [[DOTCAPTURE_EXPR_1]], align 8, !dbg [[DBG14]]
// CHECK5-NEXT:    [[TMP0:%.*]] = load double, ptr undef, align 8, !dbg [[DBG15:![0-9]+]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[ADD:%.*]] = fadd double 2.000000e+00, [[TMP0]], !dbg [[DBG15]]
// CHECK5-NEXT:    store double [[ADD]], ptr [[DOTCAPTURE_EXPR_1]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i64 poison, !dbg [[DBG14]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON4]], ptr [[DOTCAPTURE_EXPR_3]], align 8, !dbg [[DBG14]]
// CHECK5-NEXT:    [[TMP1:%.*]] = load double, ptr [[DOTCAPTURE_EXPR_1]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[SUB:%.*]] = fsub double [[TMP1]], 1.000000e+00, !dbg [[DBG15]]
// CHECK5-NEXT:    [[DIV:%.*]] = fdiv double [[SUB]], 1.000000e+00, !dbg [[DBG15]]
// CHECK5-NEXT:    [[CONV:%.*]] = fptoui double [[DIV]] to i64, !dbg [[DBG15]]
// CHECK5-NEXT:    [[SUB5:%.*]] = sub i64 [[CONV]], 1, !dbg [[DBG15]]
// CHECK5-NEXT:    store i64 [[SUB5]], ptr [[DOTCAPTURE_EXPR_3]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[FREEZE_POISON6:%.*]] = freeze i64 poison, !dbg [[DBG14]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON6]], ptr [[I]], align 8, !dbg [[DBG14]]
// CHECK5-NEXT:    store i64 1, ptr [[I]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[TMP2:%.*]] = load double, ptr [[DOTCAPTURE_EXPR_1]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[CMP:%.*]] = fcmp olt double 1.000000e+00, [[TMP2]], !dbg [[DBG15]]
// CHECK5-NEXT:    br i1 [[CMP]], label [[OMP_PRECOND_THEN:%.*]], label [[OMP_PRECOND_END:%.*]], !dbg [[DBG14]]
// CHECK5:       omp.precond.then:
// CHECK5-NEXT:    [[FREEZE_POISON7:%.*]] = freeze i64 poison, !dbg [[DBG14]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON7]], ptr [[DOTOMP_LB]], align 8, !dbg [[DBG14]]
// CHECK5-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[FREEZE_POISON8:%.*]] = freeze i64 poison, !dbg [[DBG14]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON8]], ptr [[DOTOMP_UB]], align 8, !dbg [[DBG14]]
// CHECK5-NEXT:    [[TMP3:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    store i64 [[TMP3]], ptr [[DOTOMP_UB]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[FREEZE_POISON9:%.*]] = freeze i64 poison, !dbg [[DBG14]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON9]], ptr [[DOTOMP_STRIDE]], align 8, !dbg [[DBG14]]
// CHECK5-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[FREEZE_POISON10:%.*]] = freeze i32 poison, !dbg [[DBG14]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON10]], ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG14]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG15]]
// CHECK5-NEXT:    [[FREEZE_POISON11:%.*]] = freeze double poison, !dbg [[DBG14]]
// CHECK5-NEXT:    store double [[FREEZE_POISON11]], ptr [[A]], align 8, !dbg [[DBG14]]
// CHECK5-NEXT:    [[FREEZE_POISON13:%.*]] = freeze i64 poison, !dbg [[DBG14]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON13]], ptr [[I12]], align 8, !dbg [[DBG14]]
// CHECK5-NEXT:    [[TMP4:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR__ADDR]], align 1, !dbg [[DBG14]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[CONV14:%.*]] = sext i8 [[TMP4]] to i64, !dbg [[DBG14]]
// CHECK5-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG14]]
// CHECK5-NEXT:    [[TMP6:%.*]] = load i32, ptr [[TMP5]], align 4, !dbg [[DBG14]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void @__kmpc_for_static_init_8u(ptr @[[GLOB1:[0-9]+]], i32 [[TMP6]], i32 33, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i64 1, i64 [[CONV14]]), !dbg [[DBG14]]
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND:%.*]], !dbg [[DBG14]]
// CHECK5:       omp.dispatch.cond:
// CHECK5-NEXT:    [[TMP7:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[TMP8:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[CMP15:%.*]] = icmp ugt i64 [[TMP7]], [[TMP8]], !dbg [[DBG15]]
// CHECK5-NEXT:    br i1 [[CMP15]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]], !dbg [[DBG15]]
// CHECK5:       cond.true:
// CHECK5-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    br label [[COND_END:%.*]], !dbg [[DBG15]]
// CHECK5:       cond.false:
// CHECK5-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    br label [[COND_END]], !dbg [[DBG15]]
// CHECK5:       cond.end:
// CHECK5-NEXT:    [[COND:%.*]] = phi i64 [ [[TMP9]], [[COND_TRUE]] ], [ [[TMP10]], [[COND_FALSE]] ], !dbg [[DBG15]]
// CHECK5-NEXT:    store i64 [[COND]], ptr [[DOTOMP_UB]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[TMP11:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    store i64 [[TMP11]], ptr [[DOTOMP_IV]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[TMP12:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[TMP13:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[ADD16:%.*]] = add i64 [[TMP13]], 1, !dbg [[DBG15]]
// CHECK5-NEXT:    [[CMP17:%.*]] = icmp ult i64 [[TMP12]], [[ADD16]], !dbg [[DBG15]]
// CHECK5-NEXT:    br i1 [[CMP17]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]], !dbg [[DBG14]]
// CHECK5:       omp.dispatch.body:
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]], !dbg [[DBG14]]
// CHECK5:       omp.inner.for.cond:
// CHECK5-NEXT:    [[TMP14:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[TMP15:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[ADD18:%.*]] = add i64 [[TMP15]], 1, !dbg [[DBG15]]
// CHECK5-NEXT:    [[CMP19:%.*]] = icmp ult i64 [[TMP14]], [[ADD18]], !dbg [[DBG15]]
// CHECK5-NEXT:    br i1 [[CMP19]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]], !dbg [[DBG14]]
// CHECK5:       omp.inner.for.body:
// CHECK5-NEXT:    [[TMP16:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[MUL:%.*]] = mul i64 [[TMP16]], 1, !dbg [[DBG15]]
// CHECK5-NEXT:    [[ADD20:%.*]] = add i64 1, [[MUL]], !dbg [[DBG15]]
// CHECK5-NEXT:    store i64 [[ADD20]], ptr [[I12]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]], !dbg [[DBG16:![0-9]+]]
// CHECK5:       omp.body.continue:
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]], !dbg [[DBG14]]
// CHECK5:       omp.inner.for.inc:
// CHECK5-NEXT:    [[TMP17:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[ADD21:%.*]] = add i64 [[TMP17]], 1, !dbg [[DBG15]]
// CHECK5-NEXT:    store i64 [[ADD21]], ptr [[DOTOMP_IV]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND]], !dbg [[DBG14]], !llvm.loop [[LOOP17:![0-9]+]]
// CHECK5:       omp.inner.for.end:
// CHECK5-NEXT:    br label [[OMP_DISPATCH_INC:%.*]], !dbg [[DBG14]]
// CHECK5:       omp.dispatch.inc:
// CHECK5-NEXT:    [[TMP18:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[TMP19:%.*]] = load i64, ptr [[DOTOMP_STRIDE]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[ADD22:%.*]] = add i64 [[TMP18]], [[TMP19]], !dbg [[DBG15]]
// CHECK5-NEXT:    store i64 [[ADD22]], ptr [[DOTOMP_LB]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[TMP20:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[TMP21:%.*]] = load i64, ptr [[DOTOMP_STRIDE]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    [[ADD23:%.*]] = add i64 [[TMP20]], [[TMP21]], !dbg [[DBG15]]
// CHECK5-NEXT:    store i64 [[ADD23]], ptr [[DOTOMP_UB]], align 8, !dbg [[DBG15]]
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND]], !dbg [[DBG14]], !llvm.loop [[LOOP18:![0-9]+]]
// CHECK5:       omp.dispatch.end:
// CHECK5-NEXT:    [[TMP22:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG14]]
// CHECK5-NEXT:    [[TMP23:%.*]] = load i32, ptr [[TMP22]], align 4, !dbg [[DBG14]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB3:[0-9]+]], i32 [[TMP23]]), !dbg [[DBG14]]
// CHECK5-NEXT:    br label [[OMP_PRECOND_END]], !dbg [[DBG14]]
// CHECK5:       omp.precond.end:
// CHECK5-NEXT:    ret void, !dbg [[DBG16]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z23without_schedule_clausePfS_S_S_
// CHECK5-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] !dbg [[DBG21:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB9:[0-9]+]], i32 4, ptr @_Z23without_schedule_clausePfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]]), !dbg [[DBG22:![0-9]+]]
// CHECK5-NEXT:    ret void, !dbg [[DBG23:![0-9]+]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z23without_schedule_clausePfS_S_S_.omp_outlined
// CHECK5-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] !dbg [[DBG24:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !dbg [[DBG25:![0-9]+]], !nonnull [[META9]], !align [[META26:![0-9]+]]
// CHECK5-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !dbg [[DBG25]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !dbg [[DBG25]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !dbg [[DBG25]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison, !dbg [[DBG25]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG25]]
// CHECK5-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison, !dbg [[DBG25]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4, !dbg [[DBG25]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG27:![0-9]+]]
// CHECK5-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison, !dbg [[DBG25]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG25]]
// CHECK5-NEXT:    store i32 4571423, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison, !dbg [[DBG25]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG25]]
// CHECK5-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison, !dbg [[DBG25]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG25]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison, !dbg [[DBG25]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[I]], align 4, !dbg [[DBG25]]
// CHECK5-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG25]]
// CHECK5-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !dbg [[DBG25]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB6:[0-9]+]], i32 [[TMP5]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1), !dbg [[DBG25]]
// CHECK5-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP6]], 4571423, !dbg [[DBG27]]
// CHECK5-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]], !dbg [[DBG27]]
// CHECK5:       cond.true:
// CHECK5-NEXT:    br label [[COND_END:%.*]], !dbg [[DBG27]]
// CHECK5:       cond.false:
// CHECK5-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    br label [[COND_END]], !dbg [[DBG27]]
// CHECK5:       cond.end:
// CHECK5-NEXT:    [[COND:%.*]] = phi i32 [ 4571423, [[COND_TRUE]] ], [ [[TMP7]], [[COND_FALSE]] ], !dbg [[DBG27]]
// CHECK5-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    store i32 [[TMP8]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]], !dbg [[DBG25]]
// CHECK5:       omp.inner.for.cond:
// CHECK5-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    [[CMP6:%.*]] = icmp sle i32 [[TMP9]], [[TMP10]], !dbg [[DBG27]]
// CHECK5-NEXT:    br i1 [[CMP6]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]], !dbg [[DBG25]]
// CHECK5:       omp.inner.for.body:
// CHECK5-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP11]], 7, !dbg [[DBG27]]
// CHECK5-NEXT:    [[ADD:%.*]] = add nsw i32 33, [[MUL]], !dbg [[DBG27]]
// CHECK5-NEXT:    store i32 [[ADD]], ptr [[I]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG28:![0-9]+]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG28]]
// CHECK5-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP13]] to i64, !dbg [[DBG28]]
// CHECK5-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[TMP12]], i64 [[IDXPROM]], !dbg [[DBG28]]
// CHECK5-NEXT:    [[TMP14:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !dbg [[DBG28]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG28]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP16:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG28]]
// CHECK5-NEXT:    [[IDXPROM7:%.*]] = sext i32 [[TMP16]] to i64, !dbg [[DBG28]]
// CHECK5-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[TMP15]], i64 [[IDXPROM7]], !dbg [[DBG28]]
// CHECK5-NEXT:    [[TMP17:%.*]] = load float, ptr [[ARRAYIDX8]], align 4, !dbg [[DBG28]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL9:%.*]] = fmul float [[TMP14]], [[TMP17]], !dbg [[DBG28]]
// CHECK5-NEXT:    [[TMP18:%.*]] = load ptr, ptr [[TMP3]], align 8, !dbg [[DBG28]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP19:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG28]]
// CHECK5-NEXT:    [[IDXPROM10:%.*]] = sext i32 [[TMP19]] to i64, !dbg [[DBG28]]
// CHECK5-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds float, ptr [[TMP18]], i64 [[IDXPROM10]], !dbg [[DBG28]]
// CHECK5-NEXT:    [[TMP20:%.*]] = load float, ptr [[ARRAYIDX11]], align 4, !dbg [[DBG28]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL12:%.*]] = fmul float [[MUL9]], [[TMP20]], !dbg [[DBG28]]
// CHECK5-NEXT:    [[TMP21:%.*]] = load ptr, ptr [[TMP0]], align 8, !dbg [[DBG28]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP22:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG28]]
// CHECK5-NEXT:    [[IDXPROM13:%.*]] = sext i32 [[TMP22]] to i64, !dbg [[DBG28]]
// CHECK5-NEXT:    [[ARRAYIDX14:%.*]] = getelementptr inbounds float, ptr [[TMP21]], i64 [[IDXPROM13]], !dbg [[DBG28]]
// CHECK5-NEXT:    store float [[MUL12]], ptr [[ARRAYIDX14]], align 4, !dbg [[DBG28]]
// CHECK5-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]], !dbg [[DBG29:![0-9]+]]
// CHECK5:       omp.body.continue:
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]], !dbg [[DBG25]]
// CHECK5:       omp.inner.for.inc:
// CHECK5-NEXT:    [[TMP23:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    [[ADD15:%.*]] = add nsw i32 [[TMP23]], 1, !dbg [[DBG27]]
// CHECK5-NEXT:    store i32 [[ADD15]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG27]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND]], !dbg [[DBG25]], !llvm.loop [[LOOP30:![0-9]+]]
// CHECK5:       omp.inner.for.end:
// CHECK5-NEXT:    br label [[OMP_LOOP_EXIT:%.*]], !dbg [[DBG25]]
// CHECK5:       omp.loop.exit:
// CHECK5-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB8:[0-9]+]], i32 [[TMP5]]), !dbg [[DBG25]]
// CHECK5-NEXT:    ret void, !dbg [[DBG29]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z18static_not_chunkedPfS_S_S_
// CHECK5-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] !dbg [[DBG31:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB14:[0-9]+]], i32 4, ptr @_Z18static_not_chunkedPfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]]), !dbg [[DBG32:![0-9]+]]
// CHECK5-NEXT:    ret void, !dbg [[DBG33:![0-9]+]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z18static_not_chunkedPfS_S_S_.omp_outlined
// CHECK5-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] !dbg [[DBG34:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !dbg [[DBG35:![0-9]+]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !dbg [[DBG35]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !dbg [[DBG35]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !dbg [[DBG35]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison, !dbg [[DBG35]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG35]]
// CHECK5-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison, !dbg [[DBG35]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4, !dbg [[DBG35]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG36:![0-9]+]]
// CHECK5-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison, !dbg [[DBG35]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG35]]
// CHECK5-NEXT:    store i32 4571423, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison, !dbg [[DBG35]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG35]]
// CHECK5-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison, !dbg [[DBG35]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG35]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison, !dbg [[DBG35]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[I]], align 4, !dbg [[DBG35]]
// CHECK5-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG35]]
// CHECK5-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !dbg [[DBG35]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB11:[0-9]+]], i32 [[TMP5]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1), !dbg [[DBG35]]
// CHECK5-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP6]], 4571423, !dbg [[DBG36]]
// CHECK5-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]], !dbg [[DBG36]]
// CHECK5:       cond.true:
// CHECK5-NEXT:    br label [[COND_END:%.*]], !dbg [[DBG36]]
// CHECK5:       cond.false:
// CHECK5-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    br label [[COND_END]], !dbg [[DBG36]]
// CHECK5:       cond.end:
// CHECK5-NEXT:    [[COND:%.*]] = phi i32 [ 4571423, [[COND_TRUE]] ], [ [[TMP7]], [[COND_FALSE]] ], !dbg [[DBG36]]
// CHECK5-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    store i32 [[TMP8]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]], !dbg [[DBG35]]
// CHECK5:       omp.inner.for.cond:
// CHECK5-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    [[CMP6:%.*]] = icmp sle i32 [[TMP9]], [[TMP10]], !dbg [[DBG36]]
// CHECK5-NEXT:    br i1 [[CMP6]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]], !dbg [[DBG35]]
// CHECK5:       omp.inner.for.body:
// CHECK5-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP11]], 7, !dbg [[DBG36]]
// CHECK5-NEXT:    [[SUB:%.*]] = sub nsw i32 32000000, [[MUL]], !dbg [[DBG36]]
// CHECK5-NEXT:    store i32 [[SUB]], ptr [[I]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG37:![0-9]+]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG37]]
// CHECK5-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP13]] to i64, !dbg [[DBG37]]
// CHECK5-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[TMP12]], i64 [[IDXPROM]], !dbg [[DBG37]]
// CHECK5-NEXT:    [[TMP14:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !dbg [[DBG37]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG37]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP16:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG37]]
// CHECK5-NEXT:    [[IDXPROM7:%.*]] = sext i32 [[TMP16]] to i64, !dbg [[DBG37]]
// CHECK5-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[TMP15]], i64 [[IDXPROM7]], !dbg [[DBG37]]
// CHECK5-NEXT:    [[TMP17:%.*]] = load float, ptr [[ARRAYIDX8]], align 4, !dbg [[DBG37]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL9:%.*]] = fmul float [[TMP14]], [[TMP17]], !dbg [[DBG37]]
// CHECK5-NEXT:    [[TMP18:%.*]] = load ptr, ptr [[TMP3]], align 8, !dbg [[DBG37]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP19:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG37]]
// CHECK5-NEXT:    [[IDXPROM10:%.*]] = sext i32 [[TMP19]] to i64, !dbg [[DBG37]]
// CHECK5-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds float, ptr [[TMP18]], i64 [[IDXPROM10]], !dbg [[DBG37]]
// CHECK5-NEXT:    [[TMP20:%.*]] = load float, ptr [[ARRAYIDX11]], align 4, !dbg [[DBG37]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL12:%.*]] = fmul float [[MUL9]], [[TMP20]], !dbg [[DBG37]]
// CHECK5-NEXT:    [[TMP21:%.*]] = load ptr, ptr [[TMP0]], align 8, !dbg [[DBG37]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP22:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG37]]
// CHECK5-NEXT:    [[IDXPROM13:%.*]] = sext i32 [[TMP22]] to i64, !dbg [[DBG37]]
// CHECK5-NEXT:    [[ARRAYIDX14:%.*]] = getelementptr inbounds float, ptr [[TMP21]], i64 [[IDXPROM13]], !dbg [[DBG37]]
// CHECK5-NEXT:    store float [[MUL12]], ptr [[ARRAYIDX14]], align 4, !dbg [[DBG37]]
// CHECK5-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]], !dbg [[DBG38:![0-9]+]]
// CHECK5:       omp.body.continue:
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]], !dbg [[DBG35]]
// CHECK5:       omp.inner.for.inc:
// CHECK5-NEXT:    [[TMP23:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP23]], 1, !dbg [[DBG36]]
// CHECK5-NEXT:    store i32 [[ADD]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG36]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND]], !dbg [[DBG35]], !llvm.loop [[LOOP39:![0-9]+]]
// CHECK5:       omp.inner.for.end:
// CHECK5-NEXT:    br label [[OMP_LOOP_EXIT:%.*]], !dbg [[DBG35]]
// CHECK5:       omp.loop.exit:
// CHECK5-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB13:[0-9]+]], i32 [[TMP5]]), !dbg [[DBG35]]
// CHECK5-NEXT:    ret void, !dbg [[DBG38]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z14static_chunkedPfS_S_S_
// CHECK5-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] !dbg [[DBG40:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB19:[0-9]+]], i32 4, ptr @_Z14static_chunkedPfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]]), !dbg [[DBG41:![0-9]+]]
// CHECK5-NEXT:    ret void, !dbg [[DBG42:![0-9]+]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z14static_chunkedPfS_S_S_.omp_outlined
// CHECK5-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] !dbg [[DBG43:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !dbg [[DBG44:![0-9]+]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !dbg [[DBG44]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !dbg [[DBG44]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !dbg [[DBG44]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison, !dbg [[DBG44]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG44]]
// CHECK5-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison, !dbg [[DBG44]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4, !dbg [[DBG44]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG45:![0-9]+]]
// CHECK5-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison, !dbg [[DBG44]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG44]]
// CHECK5-NEXT:    store i32 16908288, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison, !dbg [[DBG44]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG44]]
// CHECK5-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison, !dbg [[DBG44]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG44]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison, !dbg [[DBG44]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[I]], align 4, !dbg [[DBG44]]
// CHECK5-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG44]]
// CHECK5-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !dbg [[DBG44]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void @__kmpc_for_static_init_4u(ptr @[[GLOB16:[0-9]+]], i32 [[TMP5]], i32 33, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 5), !dbg [[DBG44]]
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND:%.*]], !dbg [[DBG44]]
// CHECK5:       omp.dispatch.cond:
// CHECK5-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[TMP6]], 16908288, !dbg [[DBG45]]
// CHECK5-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]], !dbg [[DBG45]]
// CHECK5:       cond.true:
// CHECK5-NEXT:    br label [[COND_END:%.*]], !dbg [[DBG45]]
// CHECK5:       cond.false:
// CHECK5-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    br label [[COND_END]], !dbg [[DBG45]]
// CHECK5:       cond.end:
// CHECK5-NEXT:    [[COND:%.*]] = phi i32 [ 16908288, [[COND_TRUE]] ], [ [[TMP7]], [[COND_FALSE]] ], !dbg [[DBG45]]
// CHECK5-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    store i32 [[TMP8]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[CMP6:%.*]] = icmp ule i32 [[TMP9]], [[TMP10]], !dbg [[DBG45]]
// CHECK5-NEXT:    br i1 [[CMP6]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]], !dbg [[DBG44]]
// CHECK5:       omp.dispatch.body:
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]], !dbg [[DBG44]]
// CHECK5:       omp.inner.for.cond:
// CHECK5-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[CMP7:%.*]] = icmp ule i32 [[TMP11]], [[TMP12]], !dbg [[DBG45]]
// CHECK5-NEXT:    br i1 [[CMP7]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]], !dbg [[DBG44]]
// CHECK5:       omp.inner.for.body:
// CHECK5-NEXT:    [[TMP13:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[MUL:%.*]] = mul i32 [[TMP13]], 127, !dbg [[DBG45]]
// CHECK5-NEXT:    [[ADD:%.*]] = add i32 131071, [[MUL]], !dbg [[DBG45]]
// CHECK5-NEXT:    store i32 [[ADD]], ptr [[I]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG46:![0-9]+]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP15:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG46]]
// CHECK5-NEXT:    [[IDXPROM:%.*]] = zext i32 [[TMP15]] to i64, !dbg [[DBG46]]
// CHECK5-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP14]], i64 [[IDXPROM]], !dbg [[DBG46]]
// CHECK5-NEXT:    [[TMP16:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !dbg [[DBG46]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG46]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP18:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG46]]
// CHECK5-NEXT:    [[IDXPROM8:%.*]] = zext i32 [[TMP18]] to i64, !dbg [[DBG46]]
// CHECK5-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds nuw float, ptr [[TMP17]], i64 [[IDXPROM8]], !dbg [[DBG46]]
// CHECK5-NEXT:    [[TMP19:%.*]] = load float, ptr [[ARRAYIDX9]], align 4, !dbg [[DBG46]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL10:%.*]] = fmul float [[TMP16]], [[TMP19]], !dbg [[DBG46]]
// CHECK5-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[TMP3]], align 8, !dbg [[DBG46]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP21:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG46]]
// CHECK5-NEXT:    [[IDXPROM11:%.*]] = zext i32 [[TMP21]] to i64, !dbg [[DBG46]]
// CHECK5-NEXT:    [[ARRAYIDX12:%.*]] = getelementptr inbounds nuw float, ptr [[TMP20]], i64 [[IDXPROM11]], !dbg [[DBG46]]
// CHECK5-NEXT:    [[TMP22:%.*]] = load float, ptr [[ARRAYIDX12]], align 4, !dbg [[DBG46]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL13:%.*]] = fmul float [[MUL10]], [[TMP22]], !dbg [[DBG46]]
// CHECK5-NEXT:    [[TMP23:%.*]] = load ptr, ptr [[TMP0]], align 8, !dbg [[DBG46]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP24:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG46]]
// CHECK5-NEXT:    [[IDXPROM14:%.*]] = zext i32 [[TMP24]] to i64, !dbg [[DBG46]]
// CHECK5-NEXT:    [[ARRAYIDX15:%.*]] = getelementptr inbounds nuw float, ptr [[TMP23]], i64 [[IDXPROM14]], !dbg [[DBG46]]
// CHECK5-NEXT:    store float [[MUL13]], ptr [[ARRAYIDX15]], align 4, !dbg [[DBG46]]
// CHECK5-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]], !dbg [[DBG47:![0-9]+]]
// CHECK5:       omp.body.continue:
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]], !dbg [[DBG44]]
// CHECK5:       omp.inner.for.inc:
// CHECK5-NEXT:    [[TMP25:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[ADD16:%.*]] = add i32 [[TMP25]], 1, !dbg [[DBG45]]
// CHECK5-NEXT:    store i32 [[ADD16]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND]], !dbg [[DBG44]], !llvm.loop [[LOOP48:![0-9]+]]
// CHECK5:       omp.inner.for.end:
// CHECK5-NEXT:    br label [[OMP_DISPATCH_INC:%.*]], !dbg [[DBG44]]
// CHECK5:       omp.dispatch.inc:
// CHECK5-NEXT:    [[TMP26:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[TMP27:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[ADD17:%.*]] = add i32 [[TMP26]], [[TMP27]], !dbg [[DBG45]]
// CHECK5-NEXT:    store i32 [[ADD17]], ptr [[DOTOMP_LB]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[TMP28:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[TMP29:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    [[ADD18:%.*]] = add i32 [[TMP28]], [[TMP29]], !dbg [[DBG45]]
// CHECK5-NEXT:    store i32 [[ADD18]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG45]]
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND]], !dbg [[DBG44]], !llvm.loop [[LOOP49:![0-9]+]]
// CHECK5:       omp.dispatch.end:
// CHECK5-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB18:[0-9]+]], i32 [[TMP5]]), !dbg [[DBG44]]
// CHECK5-NEXT:    ret void, !dbg [[DBG47]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z8dynamic1PfS_S_S_
// CHECK5-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] !dbg [[DBG50:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB21:[0-9]+]], i32 4, ptr @_Z8dynamic1PfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]]), !dbg [[DBG51:![0-9]+]]
// CHECK5-NEXT:    ret void, !dbg [[DBG52:![0-9]+]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z8dynamic1PfS_S_S_.omp_outlined
// CHECK5-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] !dbg [[DBG53:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[TMP:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[I:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !dbg [[DBG54:![0-9]+]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !dbg [[DBG54]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !dbg [[DBG54]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !dbg [[DBG54]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison, !dbg [[DBG54]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8, !dbg [[DBG54]]
// CHECK5-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i64 poison, !dbg [[DBG54]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 8, !dbg [[DBG54]]
// CHECK5-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8, !dbg [[DBG55:![0-9]+]]
// CHECK5-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i64 poison, !dbg [[DBG54]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 8, !dbg [[DBG54]]
// CHECK5-NEXT:    store i64 16908287, ptr [[DOTOMP_UB]], align 8, !dbg [[DBG55]]
// CHECK5-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i64 poison, !dbg [[DBG54]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 8, !dbg [[DBG54]]
// CHECK5-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8, !dbg [[DBG55]]
// CHECK5-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison, !dbg [[DBG54]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG54]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG55]]
// CHECK5-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i64 poison, !dbg [[DBG54]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON5]], ptr [[I]], align 8, !dbg [[DBG54]]
// CHECK5-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG54]]
// CHECK5-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !dbg [[DBG54]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void @__kmpc_dispatch_init_8u(ptr @[[GLOB21]], i32 [[TMP5]], i32 1073741859, i64 0, i64 16908287, i64 1, i64 1), !dbg [[DBG54]]
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND:%.*]], !dbg [[DBG54]]
// CHECK5:       omp.dispatch.cond:
// CHECK5-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_dispatch_next_8u(ptr @[[GLOB21]], i32 [[TMP5]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]]), !dbg [[DBG54]]
// CHECK5-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP6]], 0, !dbg [[DBG54]]
// CHECK5-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]], !dbg [[DBG54]]
// CHECK5:       omp.dispatch.body:
// CHECK5-NEXT:    [[TMP7:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8, !dbg [[DBG55]]
// CHECK5-NEXT:    store i64 [[TMP7]], ptr [[DOTOMP_IV]], align 8, !dbg [[DBG55]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]], !dbg [[DBG54]]
// CHECK5:       omp.inner.for.cond:
// CHECK5-NEXT:    [[TMP8:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG55]], !llvm.access.group [[ACC_GRP56:![0-9]+]]
// CHECK5-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !dbg [[DBG55]], !llvm.access.group [[ACC_GRP56]]
// CHECK5-NEXT:    [[ADD:%.*]] = add i64 [[TMP9]], 1, !dbg [[DBG55]]
// CHECK5-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TMP8]], [[ADD]], !dbg [[DBG55]]
// CHECK5-NEXT:    br i1 [[CMP]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]], !dbg [[DBG54]]
// CHECK5:       omp.inner.for.body:
// CHECK5-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG55]], !llvm.access.group [[ACC_GRP56]]
// CHECK5-NEXT:    [[MUL:%.*]] = mul i64 [[TMP10]], 127, !dbg [[DBG55]]
// CHECK5-NEXT:    [[ADD6:%.*]] = add i64 131071, [[MUL]], !dbg [[DBG55]]
// CHECK5-NEXT:    store i64 [[ADD6]], ptr [[I]], align 8, !dbg [[DBG55]], !llvm.access.group [[ACC_GRP56]]
// CHECK5-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG57:![0-9]+]], !llvm.access.group [[ACC_GRP56]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP12:%.*]] = load i64, ptr [[I]], align 8, !dbg [[DBG57]], !llvm.access.group [[ACC_GRP56]]
// CHECK5-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP11]], i64 [[TMP12]], !dbg [[DBG57]]
// CHECK5-NEXT:    [[TMP13:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !dbg [[DBG57]], !llvm.access.group [[ACC_GRP56]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG57]], !llvm.access.group [[ACC_GRP56]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP15:%.*]] = load i64, ptr [[I]], align 8, !dbg [[DBG57]], !llvm.access.group [[ACC_GRP56]]
// CHECK5-NEXT:    [[ARRAYIDX7:%.*]] = getelementptr inbounds nuw float, ptr [[TMP14]], i64 [[TMP15]], !dbg [[DBG57]]
// CHECK5-NEXT:    [[TMP16:%.*]] = load float, ptr [[ARRAYIDX7]], align 4, !dbg [[DBG57]], !llvm.access.group [[ACC_GRP56]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL8:%.*]] = fmul float [[TMP13]], [[TMP16]], !dbg [[DBG57]]
// CHECK5-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP3]], align 8, !dbg [[DBG57]], !llvm.access.group [[ACC_GRP56]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP18:%.*]] = load i64, ptr [[I]], align 8, !dbg [[DBG57]], !llvm.access.group [[ACC_GRP56]]
// CHECK5-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds nuw float, ptr [[TMP17]], i64 [[TMP18]], !dbg [[DBG57]]
// CHECK5-NEXT:    [[TMP19:%.*]] = load float, ptr [[ARRAYIDX9]], align 4, !dbg [[DBG57]], !llvm.access.group [[ACC_GRP56]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL10:%.*]] = fmul float [[MUL8]], [[TMP19]], !dbg [[DBG57]]
// CHECK5-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[TMP0]], align 8, !dbg [[DBG57]], !llvm.access.group [[ACC_GRP56]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP21:%.*]] = load i64, ptr [[I]], align 8, !dbg [[DBG57]], !llvm.access.group [[ACC_GRP56]]
// CHECK5-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds nuw float, ptr [[TMP20]], i64 [[TMP21]], !dbg [[DBG57]]
// CHECK5-NEXT:    store float [[MUL10]], ptr [[ARRAYIDX11]], align 4, !dbg [[DBG57]], !llvm.access.group [[ACC_GRP56]]
// CHECK5-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]], !dbg [[DBG58:![0-9]+]]
// CHECK5:       omp.body.continue:
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]], !dbg [[DBG54]]
// CHECK5:       omp.inner.for.inc:
// CHECK5-NEXT:    [[TMP22:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG55]], !llvm.access.group [[ACC_GRP56]]
// CHECK5-NEXT:    [[ADD12:%.*]] = add i64 [[TMP22]], 1, !dbg [[DBG55]]
// CHECK5-NEXT:    store i64 [[ADD12]], ptr [[DOTOMP_IV]], align 8, !dbg [[DBG55]], !llvm.access.group [[ACC_GRP56]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND]], !dbg [[DBG54]], !llvm.loop [[LOOP59:![0-9]+]]
// CHECK5:       omp.inner.for.end:
// CHECK5-NEXT:    br label [[OMP_DISPATCH_INC:%.*]], !dbg [[DBG54]]
// CHECK5:       omp.dispatch.inc:
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND]], !dbg [[DBG54]], !llvm.loop [[LOOP61:![0-9]+]]
// CHECK5:       omp.dispatch.end:
// CHECK5-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB21]], i32 [[TMP5]]), !dbg [[DBG54]]
// CHECK5-NEXT:    ret void, !dbg [[DBG58]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z7guided7PfS_S_S_
// CHECK5-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] !dbg [[DBG62:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB23:[0-9]+]], i32 4, ptr @_Z7guided7PfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]]), !dbg [[DBG63:![0-9]+]]
// CHECK5-NEXT:    ret void, !dbg [[DBG64:![0-9]+]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z7guided7PfS_S_S_.omp_outlined
// CHECK5-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] !dbg [[DBG65:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[TMP:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[I:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !dbg [[DBG66:![0-9]+]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !dbg [[DBG66]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !dbg [[DBG66]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !dbg [[DBG66]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison, !dbg [[DBG66]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8, !dbg [[DBG66]]
// CHECK5-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i64 poison, !dbg [[DBG66]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 8, !dbg [[DBG66]]
// CHECK5-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8, !dbg [[DBG67:![0-9]+]]
// CHECK5-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i64 poison, !dbg [[DBG66]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 8, !dbg [[DBG66]]
// CHECK5-NEXT:    store i64 16908287, ptr [[DOTOMP_UB]], align 8, !dbg [[DBG67]]
// CHECK5-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i64 poison, !dbg [[DBG66]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 8, !dbg [[DBG66]]
// CHECK5-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8, !dbg [[DBG67]]
// CHECK5-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison, !dbg [[DBG66]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG66]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG67]]
// CHECK5-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i64 poison, !dbg [[DBG66]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON5]], ptr [[I]], align 8, !dbg [[DBG66]]
// CHECK5-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG66]]
// CHECK5-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !dbg [[DBG66]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void @__kmpc_dispatch_init_8u(ptr @[[GLOB23]], i32 [[TMP5]], i32 1073741860, i64 0, i64 16908287, i64 1, i64 7), !dbg [[DBG66]]
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND:%.*]], !dbg [[DBG66]]
// CHECK5:       omp.dispatch.cond:
// CHECK5-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_dispatch_next_8u(ptr @[[GLOB23]], i32 [[TMP5]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]]), !dbg [[DBG66]]
// CHECK5-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP6]], 0, !dbg [[DBG66]]
// CHECK5-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]], !dbg [[DBG66]]
// CHECK5:       omp.dispatch.body:
// CHECK5-NEXT:    [[TMP7:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8, !dbg [[DBG67]]
// CHECK5-NEXT:    store i64 [[TMP7]], ptr [[DOTOMP_IV]], align 8, !dbg [[DBG67]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]], !dbg [[DBG66]]
// CHECK5:       omp.inner.for.cond:
// CHECK5-NEXT:    [[TMP8:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG67]], !llvm.access.group [[ACC_GRP68:![0-9]+]]
// CHECK5-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !dbg [[DBG67]], !llvm.access.group [[ACC_GRP68]]
// CHECK5-NEXT:    [[ADD:%.*]] = add i64 [[TMP9]], 1, !dbg [[DBG67]]
// CHECK5-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TMP8]], [[ADD]], !dbg [[DBG67]]
// CHECK5-NEXT:    br i1 [[CMP]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]], !dbg [[DBG66]]
// CHECK5:       omp.inner.for.body:
// CHECK5-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG67]], !llvm.access.group [[ACC_GRP68]]
// CHECK5-NEXT:    [[MUL:%.*]] = mul i64 [[TMP10]], 127, !dbg [[DBG67]]
// CHECK5-NEXT:    [[ADD6:%.*]] = add i64 131071, [[MUL]], !dbg [[DBG67]]
// CHECK5-NEXT:    store i64 [[ADD6]], ptr [[I]], align 8, !dbg [[DBG67]], !llvm.access.group [[ACC_GRP68]]
// CHECK5-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG69:![0-9]+]], !llvm.access.group [[ACC_GRP68]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP12:%.*]] = load i64, ptr [[I]], align 8, !dbg [[DBG69]], !llvm.access.group [[ACC_GRP68]]
// CHECK5-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP11]], i64 [[TMP12]], !dbg [[DBG69]]
// CHECK5-NEXT:    [[TMP13:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !dbg [[DBG69]], !llvm.access.group [[ACC_GRP68]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG69]], !llvm.access.group [[ACC_GRP68]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP15:%.*]] = load i64, ptr [[I]], align 8, !dbg [[DBG69]], !llvm.access.group [[ACC_GRP68]]
// CHECK5-NEXT:    [[ARRAYIDX7:%.*]] = getelementptr inbounds nuw float, ptr [[TMP14]], i64 [[TMP15]], !dbg [[DBG69]]
// CHECK5-NEXT:    [[TMP16:%.*]] = load float, ptr [[ARRAYIDX7]], align 4, !dbg [[DBG69]], !llvm.access.group [[ACC_GRP68]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL8:%.*]] = fmul float [[TMP13]], [[TMP16]], !dbg [[DBG69]]
// CHECK5-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP3]], align 8, !dbg [[DBG69]], !llvm.access.group [[ACC_GRP68]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP18:%.*]] = load i64, ptr [[I]], align 8, !dbg [[DBG69]], !llvm.access.group [[ACC_GRP68]]
// CHECK5-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds nuw float, ptr [[TMP17]], i64 [[TMP18]], !dbg [[DBG69]]
// CHECK5-NEXT:    [[TMP19:%.*]] = load float, ptr [[ARRAYIDX9]], align 4, !dbg [[DBG69]], !llvm.access.group [[ACC_GRP68]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL10:%.*]] = fmul float [[MUL8]], [[TMP19]], !dbg [[DBG69]]
// CHECK5-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[TMP0]], align 8, !dbg [[DBG69]], !llvm.access.group [[ACC_GRP68]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP21:%.*]] = load i64, ptr [[I]], align 8, !dbg [[DBG69]], !llvm.access.group [[ACC_GRP68]]
// CHECK5-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds nuw float, ptr [[TMP20]], i64 [[TMP21]], !dbg [[DBG69]]
// CHECK5-NEXT:    store float [[MUL10]], ptr [[ARRAYIDX11]], align 4, !dbg [[DBG69]], !llvm.access.group [[ACC_GRP68]]
// CHECK5-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]], !dbg [[DBG70:![0-9]+]]
// CHECK5:       omp.body.continue:
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]], !dbg [[DBG66]]
// CHECK5:       omp.inner.for.inc:
// CHECK5-NEXT:    [[TMP22:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG67]], !llvm.access.group [[ACC_GRP68]]
// CHECK5-NEXT:    [[ADD12:%.*]] = add i64 [[TMP22]], 1, !dbg [[DBG67]]
// CHECK5-NEXT:    store i64 [[ADD12]], ptr [[DOTOMP_IV]], align 8, !dbg [[DBG67]], !llvm.access.group [[ACC_GRP68]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND]], !dbg [[DBG66]], !llvm.loop [[LOOP71:![0-9]+]]
// CHECK5:       omp.inner.for.end:
// CHECK5-NEXT:    br label [[OMP_DISPATCH_INC:%.*]], !dbg [[DBG66]]
// CHECK5:       omp.dispatch.inc:
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND]], !dbg [[DBG66]], !llvm.loop [[LOOP73:![0-9]+]]
// CHECK5:       omp.dispatch.end:
// CHECK5-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB23]], i32 [[TMP5]]), !dbg [[DBG66]]
// CHECK5-NEXT:    ret void, !dbg [[DBG70]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z9test_autoPfS_S_S_
// CHECK5-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] !dbg [[DBG74:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[Y:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison, !dbg [[DBG75:![0-9]+]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON]], ptr [[X]], align 4, !dbg [[DBG75]]
// CHECK5-NEXT:    store i32 0, ptr [[X]], align 4, !dbg [[DBG75]]
// CHECK5-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison, !dbg [[DBG76:![0-9]+]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[Y]], align 4, !dbg [[DBG76]]
// CHECK5-NEXT:    store i32 0, ptr [[Y]], align 4, !dbg [[DBG76]]
// CHECK5-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB25:[0-9]+]], i32 5, ptr @_Z9test_autoPfS_S_S_.omp_outlined, ptr [[Y]], ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]]), !dbg [[DBG77:![0-9]+]]
// CHECK5-NEXT:    ret void, !dbg [[DBG78:![0-9]+]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z9test_autoPfS_S_S_.omp_outlined
// CHECK5-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 4 dereferenceable(4) [[Y:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] !dbg [[DBG79:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[Y_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[TMP:%.*]] = alloca i8, align 1
// CHECK5-NEXT:    [[_TMP1:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTCAPTURE_EXPR_:%.*]] = alloca i8, align 1
// CHECK5-NEXT:    [[DOTCAPTURE_EXPR_3:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[I:%.*]] = alloca i8, align 1
// CHECK5-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[I15:%.*]] = alloca i8, align 1
// CHECK5-NEXT:    [[X17:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[Y]], ptr [[Y_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[Y_ADDR]], align 8, !dbg [[DBG80:![0-9]+]], !nonnull [[META9]], !align [[META81:![0-9]+]]
// CHECK5-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !dbg [[DBG80]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !dbg [[DBG80]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !dbg [[DBG80]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !dbg [[DBG80]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison, !dbg [[DBG80]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8, !dbg [[DBG80]]
// CHECK5-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i8 poison, !dbg [[DBG80]]
// CHECK5-NEXT:    store i8 [[FREEZE_POISON2]], ptr [[DOTCAPTURE_EXPR_]], align 1, !dbg [[DBG80]]
// CHECK5-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP0]], align 4, !dbg [[DBG82:![0-9]+]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[CONV:%.*]] = trunc i32 [[TMP5]] to i8, !dbg [[DBG82]]
// CHECK5-NEXT:    store i8 [[CONV]], ptr [[DOTCAPTURE_EXPR_]], align 1, !dbg [[DBG82]]
// CHECK5-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i64 poison, !dbg [[DBG80]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON4]], ptr [[DOTCAPTURE_EXPR_3]], align 8, !dbg [[DBG80]]
// CHECK5-NEXT:    [[TMP6:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1, !dbg [[DBG82]]
// CHECK5-NEXT:    [[CONV5:%.*]] = sext i8 [[TMP6]] to i32, !dbg [[DBG82]]
// CHECK5-NEXT:    [[SUB:%.*]] = sub i32 57, [[CONV5]], !dbg [[DBG82]]
// CHECK5-NEXT:    [[ADD:%.*]] = add i32 [[SUB]], 1, !dbg [[DBG82]]
// CHECK5-NEXT:    [[DIV:%.*]] = udiv i32 [[ADD]], 1, !dbg [[DBG82]]
// CHECK5-NEXT:    [[CONV6:%.*]] = zext i32 [[DIV]] to i64, !dbg [[DBG82]]
// CHECK5-NEXT:    [[MUL:%.*]] = mul nsw i64 [[CONV6]], 11, !dbg [[DBG83:![0-9]+]]
// CHECK5-NEXT:    [[SUB7:%.*]] = sub nsw i64 [[MUL]], 1, !dbg [[DBG83]]
// CHECK5-NEXT:    store i64 [[SUB7]], ptr [[DOTCAPTURE_EXPR_3]], align 8, !dbg [[DBG82]]
// CHECK5-NEXT:    [[FREEZE_POISON8:%.*]] = freeze i8 poison, !dbg [[DBG80]]
// CHECK5-NEXT:    store i8 [[FREEZE_POISON8]], ptr [[I]], align 1, !dbg [[DBG80]]
// CHECK5-NEXT:    [[FREEZE_POISON9:%.*]] = freeze i32 poison, !dbg [[DBG80]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON9]], ptr [[X]], align 4, !dbg [[DBG80]]
// CHECK5-NEXT:    [[TMP7:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1, !dbg [[DBG82]]
// CHECK5-NEXT:    store i8 [[TMP7]], ptr [[I]], align 1, !dbg [[DBG82]]
// CHECK5-NEXT:    store i32 11, ptr [[X]], align 4, !dbg [[DBG83]]
// CHECK5-NEXT:    [[TMP8:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1, !dbg [[DBG82]]
// CHECK5-NEXT:    [[CONV10:%.*]] = sext i8 [[TMP8]] to i32, !dbg [[DBG82]]
// CHECK5-NEXT:    [[CMP:%.*]] = icmp sle i32 [[CONV10]], 57, !dbg [[DBG82]]
// CHECK5-NEXT:    br i1 [[CMP]], label [[OMP_PRECOND_THEN:%.*]], label [[OMP_PRECOND_END:%.*]], !dbg [[DBG80]]
// CHECK5:       omp.precond.then:
// CHECK5-NEXT:    [[FREEZE_POISON11:%.*]] = freeze i64 poison, !dbg [[DBG80]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON11]], ptr [[DOTOMP_LB]], align 8, !dbg [[DBG80]]
// CHECK5-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8, !dbg [[DBG82]]
// CHECK5-NEXT:    [[FREEZE_POISON12:%.*]] = freeze i64 poison, !dbg [[DBG80]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON12]], ptr [[DOTOMP_UB]], align 8, !dbg [[DBG80]]
// CHECK5-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8, !dbg [[DBG83]]
// CHECK5-NEXT:    store i64 [[TMP9]], ptr [[DOTOMP_UB]], align 8, !dbg [[DBG82]]
// CHECK5-NEXT:    [[FREEZE_POISON13:%.*]] = freeze i64 poison, !dbg [[DBG80]]
// CHECK5-NEXT:    store i64 [[FREEZE_POISON13]], ptr [[DOTOMP_STRIDE]], align 8, !dbg [[DBG80]]
// CHECK5-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8, !dbg [[DBG82]]
// CHECK5-NEXT:    [[FREEZE_POISON14:%.*]] = freeze i32 poison, !dbg [[DBG80]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON14]], ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG80]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG82]]
// CHECK5-NEXT:    [[FREEZE_POISON16:%.*]] = freeze i8 poison, !dbg [[DBG80]]
// CHECK5-NEXT:    store i8 [[FREEZE_POISON16]], ptr [[I15]], align 1, !dbg [[DBG80]]
// CHECK5-NEXT:    [[FREEZE_POISON18:%.*]] = freeze i32 poison, !dbg [[DBG80]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON18]], ptr [[X17]], align 4, !dbg [[DBG80]]
// CHECK5-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8, !dbg [[DBG83]]
// CHECK5-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG80]]
// CHECK5-NEXT:    [[TMP12:%.*]] = load i32, ptr [[TMP11]], align 4, !dbg [[DBG80]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void @__kmpc_dispatch_init_8(ptr @[[GLOB25]], i32 [[TMP12]], i32 1073741862, i64 0, i64 [[TMP10]], i64 1, i64 1), !dbg [[DBG80]]
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND:%.*]], !dbg [[DBG80]]
// CHECK5:       omp.dispatch.cond:
// CHECK5-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG80]]
// CHECK5-NEXT:    [[TMP14:%.*]] = load i32, ptr [[TMP13]], align 4, !dbg [[DBG80]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP15:%.*]] = call i32 @__kmpc_dispatch_next_8(ptr @[[GLOB25]], i32 [[TMP14]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]]), !dbg [[DBG80]]
// CHECK5-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP15]], 0, !dbg [[DBG80]]
// CHECK5-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]], !dbg [[DBG80]]
// CHECK5:       omp.dispatch.body:
// CHECK5-NEXT:    [[TMP16:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8, !dbg [[DBG82]]
// CHECK5-NEXT:    store i64 [[TMP16]], ptr [[DOTOMP_IV]], align 8, !dbg [[DBG82]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]], !dbg [[DBG80]]
// CHECK5:       omp.inner.for.cond:
// CHECK5-NEXT:    [[TMP17:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG82]], !llvm.access.group [[ACC_GRP84:![0-9]+]]
// CHECK5-NEXT:    [[TMP18:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !dbg [[DBG82]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    [[CMP19:%.*]] = icmp sle i64 [[TMP17]], [[TMP18]], !dbg [[DBG82]]
// CHECK5-NEXT:    br i1 [[CMP19]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]], !dbg [[DBG80]]
// CHECK5:       omp.inner.for.body:
// CHECK5-NEXT:    [[TMP19:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1, !dbg [[DBG82]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    [[CONV20:%.*]] = sext i8 [[TMP19]] to i64, !dbg [[DBG82]]
// CHECK5-NEXT:    [[TMP20:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG82]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    [[DIV21:%.*]] = sdiv i64 [[TMP20]], 11, !dbg [[DBG82]]
// CHECK5-NEXT:    [[MUL22:%.*]] = mul nsw i64 [[DIV21]], 1, !dbg [[DBG82]]
// CHECK5-NEXT:    [[ADD23:%.*]] = add nsw i64 [[CONV20]], [[MUL22]], !dbg [[DBG82]]
// CHECK5-NEXT:    [[CONV24:%.*]] = trunc i64 [[ADD23]] to i8, !dbg [[DBG82]]
// CHECK5-NEXT:    store i8 [[CONV24]], ptr [[I15]], align 1, !dbg [[DBG82]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    [[TMP21:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG82]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    [[TMP22:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG82]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    [[DIV25:%.*]] = sdiv i64 [[TMP22]], 11, !dbg [[DBG82]]
// CHECK5-NEXT:    [[MUL26:%.*]] = mul nsw i64 [[DIV25]], 11, !dbg [[DBG82]]
// CHECK5-NEXT:    [[SUB27:%.*]] = sub nsw i64 [[TMP21]], [[MUL26]], !dbg [[DBG82]]
// CHECK5-NEXT:    [[MUL28:%.*]] = mul nsw i64 [[SUB27]], 1, !dbg [[DBG83]]
// CHECK5-NEXT:    [[SUB29:%.*]] = sub nsw i64 11, [[MUL28]], !dbg [[DBG83]]
// CHECK5-NEXT:    [[CONV30:%.*]] = trunc i64 [[SUB29]] to i32, !dbg [[DBG83]]
// CHECK5-NEXT:    store i32 [[CONV30]], ptr [[X17]], align 4, !dbg [[DBG83]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    [[TMP23:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG85:![0-9]+]], !llvm.access.group [[ACC_GRP84]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP24:%.*]] = load i8, ptr [[I15]], align 1, !dbg [[DBG85]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    [[IDXPROM:%.*]] = sext i8 [[TMP24]] to i64, !dbg [[DBG85]]
// CHECK5-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[TMP23]], i64 [[IDXPROM]], !dbg [[DBG85]]
// CHECK5-NEXT:    [[TMP25:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !dbg [[DBG85]], !llvm.access.group [[ACC_GRP84]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP26:%.*]] = load ptr, ptr [[TMP3]], align 8, !dbg [[DBG85]], !llvm.access.group [[ACC_GRP84]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP27:%.*]] = load i8, ptr [[I15]], align 1, !dbg [[DBG85]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    [[IDXPROM31:%.*]] = sext i8 [[TMP27]] to i64, !dbg [[DBG85]]
// CHECK5-NEXT:    [[ARRAYIDX32:%.*]] = getelementptr inbounds float, ptr [[TMP26]], i64 [[IDXPROM31]], !dbg [[DBG85]]
// CHECK5-NEXT:    [[TMP28:%.*]] = load float, ptr [[ARRAYIDX32]], align 4, !dbg [[DBG85]], !llvm.access.group [[ACC_GRP84]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL33:%.*]] = fmul float [[TMP25]], [[TMP28]], !dbg [[DBG85]]
// CHECK5-NEXT:    [[TMP29:%.*]] = load ptr, ptr [[TMP4]], align 8, !dbg [[DBG85]], !llvm.access.group [[ACC_GRP84]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP30:%.*]] = load i8, ptr [[I15]], align 1, !dbg [[DBG85]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    [[IDXPROM34:%.*]] = sext i8 [[TMP30]] to i64, !dbg [[DBG85]]
// CHECK5-NEXT:    [[ARRAYIDX35:%.*]] = getelementptr inbounds float, ptr [[TMP29]], i64 [[IDXPROM34]], !dbg [[DBG85]]
// CHECK5-NEXT:    [[TMP31:%.*]] = load float, ptr [[ARRAYIDX35]], align 4, !dbg [[DBG85]], !llvm.access.group [[ACC_GRP84]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL36:%.*]] = fmul float [[MUL33]], [[TMP31]], !dbg [[DBG85]]
// CHECK5-NEXT:    [[TMP32:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG85]], !llvm.access.group [[ACC_GRP84]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP33:%.*]] = load i8, ptr [[I15]], align 1, !dbg [[DBG85]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    [[IDXPROM37:%.*]] = sext i8 [[TMP33]] to i64, !dbg [[DBG85]]
// CHECK5-NEXT:    [[ARRAYIDX38:%.*]] = getelementptr inbounds float, ptr [[TMP32]], i64 [[IDXPROM37]], !dbg [[DBG85]]
// CHECK5-NEXT:    store float [[MUL36]], ptr [[ARRAYIDX38]], align 4, !dbg [[DBG85]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]], !dbg [[DBG86:![0-9]+]]
// CHECK5:       omp.body.continue:
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]], !dbg [[DBG80]]
// CHECK5:       omp.inner.for.inc:
// CHECK5-NEXT:    [[TMP34:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !dbg [[DBG82]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    [[ADD39:%.*]] = add nsw i64 [[TMP34]], 1, !dbg [[DBG82]]
// CHECK5-NEXT:    store i64 [[ADD39]], ptr [[DOTOMP_IV]], align 8, !dbg [[DBG82]], !llvm.access.group [[ACC_GRP84]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND]], !dbg [[DBG80]], !llvm.loop [[LOOP87:![0-9]+]]
// CHECK5:       omp.inner.for.end:
// CHECK5-NEXT:    br label [[OMP_DISPATCH_INC:%.*]], !dbg [[DBG80]]
// CHECK5:       omp.dispatch.inc:
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND]], !dbg [[DBG80]], !llvm.loop [[LOOP89:![0-9]+]]
// CHECK5:       omp.dispatch.end:
// CHECK5-NEXT:    [[TMP35:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG80]]
// CHECK5-NEXT:    [[TMP36:%.*]] = load i32, ptr [[TMP35]], align 4, !dbg [[DBG80]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB25]], i32 [[TMP36]]), !dbg [[DBG80]]
// CHECK5-NEXT:    br label [[OMP_PRECOND_END]], !dbg [[DBG80]]
// CHECK5:       omp.precond.end:
// CHECK5-NEXT:    ret void, !dbg [[DBG86]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z7runtimePfS_S_S_
// CHECK5-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] !dbg [[DBG90:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison, !dbg [[DBG91:![0-9]+]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON]], ptr [[X]], align 4, !dbg [[DBG91]]
// CHECK5-NEXT:    store i32 0, ptr [[X]], align 4, !dbg [[DBG91]]
// CHECK5-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB27:[0-9]+]], i32 4, ptr @_Z7runtimePfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]]), !dbg [[DBG92:![0-9]+]]
// CHECK5-NEXT:    ret void, !dbg [[DBG93:![0-9]+]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z7runtimePfS_S_S_.omp_outlined
// CHECK5-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] !dbg [[DBG94:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[TMP:%.*]] = alloca i8, align 1
// CHECK5-NEXT:    [[_TMP1:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[I:%.*]] = alloca i8, align 1
// CHECK5-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK5-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK5-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !dbg [[DBG95:![0-9]+]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !dbg [[DBG95]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !dbg [[DBG95]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !dbg [[DBG95]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison, !dbg [[DBG95]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG95]]
// CHECK5-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison, !dbg [[DBG95]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_LB]], align 4, !dbg [[DBG95]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG96:![0-9]+]]
// CHECK5-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison, !dbg [[DBG95]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG95]]
// CHECK5-NEXT:    store i32 199, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG96]]
// CHECK5-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison, !dbg [[DBG95]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG95]]
// CHECK5-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG96]]
// CHECK5-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison, !dbg [[DBG95]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG95]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG96]]
// CHECK5-NEXT:    [[FREEZE_POISON6:%.*]] = freeze i8 poison, !dbg [[DBG95]]
// CHECK5-NEXT:    store i8 [[FREEZE_POISON6]], ptr [[I]], align 1, !dbg [[DBG95]]
// CHECK5-NEXT:    [[FREEZE_POISON7:%.*]] = freeze i32 poison, !dbg [[DBG95]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON7]], ptr [[X]], align 4, !dbg [[DBG95]]
// CHECK5-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG95]]
// CHECK5-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !dbg [[DBG95]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void @__kmpc_dispatch_init_4(ptr @[[GLOB27]], i32 [[TMP5]], i32 1073741861, i32 0, i32 199, i32 1, i32 1), !dbg [[DBG95]]
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND:%.*]], !dbg [[DBG95]]
// CHECK5:       omp.dispatch.cond:
// CHECK5-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_dispatch_next_4(ptr @[[GLOB27]], i32 [[TMP5]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]]), !dbg [[DBG95]]
// CHECK5-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP6]], 0, !dbg [[DBG95]]
// CHECK5-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]], !dbg [[DBG95]]
// CHECK5:       omp.dispatch.body:
// CHECK5-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG96]]
// CHECK5-NEXT:    store i32 [[TMP7]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG96]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]], !dbg [[DBG95]]
// CHECK5:       omp.inner.for.cond:
// CHECK5-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG96]], !llvm.access.group [[ACC_GRP97:![0-9]+]]
// CHECK5-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG96]], !llvm.access.group [[ACC_GRP97]]
// CHECK5-NEXT:    [[CMP:%.*]] = icmp sle i32 [[TMP8]], [[TMP9]], !dbg [[DBG96]]
// CHECK5-NEXT:    br i1 [[CMP]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]], !dbg [[DBG95]]
// CHECK5:       omp.inner.for.body:
// CHECK5-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG96]], !llvm.access.group [[ACC_GRP97]]
// CHECK5-NEXT:    [[DIV:%.*]] = sdiv i32 [[TMP10]], 20, !dbg [[DBG96]]
// CHECK5-NEXT:    [[MUL:%.*]] = mul nsw i32 [[DIV]], 1, !dbg [[DBG96]]
// CHECK5-NEXT:    [[ADD:%.*]] = add nsw i32 48, [[MUL]], !dbg [[DBG96]]
// CHECK5-NEXT:    [[CONV:%.*]] = trunc i32 [[ADD]] to i8, !dbg [[DBG96]]
// CHECK5-NEXT:    store i8 [[CONV]], ptr [[I]], align 1, !dbg [[DBG96]], !llvm.access.group [[ACC_GRP97]]
// CHECK5-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG96]], !llvm.access.group [[ACC_GRP97]]
// CHECK5-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG96]], !llvm.access.group [[ACC_GRP97]]
// CHECK5-NEXT:    [[DIV8:%.*]] = sdiv i32 [[TMP12]], 20, !dbg [[DBG96]]
// CHECK5-NEXT:    [[MUL9:%.*]] = mul nsw i32 [[DIV8]], 20, !dbg [[DBG96]]
// CHECK5-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP11]], [[MUL9]], !dbg [[DBG96]]
// CHECK5-NEXT:    [[MUL10:%.*]] = mul nsw i32 [[SUB]], 1, !dbg [[DBG98:![0-9]+]]
// CHECK5-NEXT:    [[ADD11:%.*]] = add nsw i32 -10, [[MUL10]], !dbg [[DBG98]]
// CHECK5-NEXT:    store i32 [[ADD11]], ptr [[X]], align 4, !dbg [[DBG98]], !llvm.access.group [[ACC_GRP97]]
// CHECK5-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[TMP1]], align 8, !dbg [[DBG99:![0-9]+]], !llvm.access.group [[ACC_GRP97]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP14:%.*]] = load i8, ptr [[I]], align 1, !dbg [[DBG99]], !llvm.access.group [[ACC_GRP97]]
// CHECK5-NEXT:    [[IDXPROM:%.*]] = zext i8 [[TMP14]] to i64, !dbg [[DBG99]]
// CHECK5-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP13]], i64 [[IDXPROM]], !dbg [[DBG99]]
// CHECK5-NEXT:    [[TMP15:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !dbg [[DBG99]], !llvm.access.group [[ACC_GRP97]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[TMP2]], align 8, !dbg [[DBG99]], !llvm.access.group [[ACC_GRP97]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP17:%.*]] = load i8, ptr [[I]], align 1, !dbg [[DBG99]], !llvm.access.group [[ACC_GRP97]]
// CHECK5-NEXT:    [[IDXPROM12:%.*]] = zext i8 [[TMP17]] to i64, !dbg [[DBG99]]
// CHECK5-NEXT:    [[ARRAYIDX13:%.*]] = getelementptr inbounds nuw float, ptr [[TMP16]], i64 [[IDXPROM12]], !dbg [[DBG99]]
// CHECK5-NEXT:    [[TMP18:%.*]] = load float, ptr [[ARRAYIDX13]], align 4, !dbg [[DBG99]], !llvm.access.group [[ACC_GRP97]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL14:%.*]] = fmul float [[TMP15]], [[TMP18]], !dbg [[DBG99]]
// CHECK5-NEXT:    [[TMP19:%.*]] = load ptr, ptr [[TMP3]], align 8, !dbg [[DBG99]], !llvm.access.group [[ACC_GRP97]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP20:%.*]] = load i8, ptr [[I]], align 1, !dbg [[DBG99]], !llvm.access.group [[ACC_GRP97]]
// CHECK5-NEXT:    [[IDXPROM15:%.*]] = zext i8 [[TMP20]] to i64, !dbg [[DBG99]]
// CHECK5-NEXT:    [[ARRAYIDX16:%.*]] = getelementptr inbounds nuw float, ptr [[TMP19]], i64 [[IDXPROM15]], !dbg [[DBG99]]
// CHECK5-NEXT:    [[TMP21:%.*]] = load float, ptr [[ARRAYIDX16]], align 4, !dbg [[DBG99]], !llvm.access.group [[ACC_GRP97]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[MUL17:%.*]] = fmul float [[MUL14]], [[TMP21]], !dbg [[DBG99]]
// CHECK5-NEXT:    [[TMP22:%.*]] = load ptr, ptr [[TMP0]], align 8, !dbg [[DBG99]], !llvm.access.group [[ACC_GRP97]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP23:%.*]] = load i8, ptr [[I]], align 1, !dbg [[DBG99]], !llvm.access.group [[ACC_GRP97]]
// CHECK5-NEXT:    [[IDXPROM18:%.*]] = zext i8 [[TMP23]] to i64, !dbg [[DBG99]]
// CHECK5-NEXT:    [[ARRAYIDX19:%.*]] = getelementptr inbounds nuw float, ptr [[TMP22]], i64 [[IDXPROM18]], !dbg [[DBG99]]
// CHECK5-NEXT:    store float [[MUL17]], ptr [[ARRAYIDX19]], align 4, !dbg [[DBG99]], !llvm.access.group [[ACC_GRP97]]
// CHECK5-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]], !dbg [[DBG100:![0-9]+]]
// CHECK5:       omp.body.continue:
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]], !dbg [[DBG95]]
// CHECK5:       omp.inner.for.inc:
// CHECK5-NEXT:    [[TMP24:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG96]], !llvm.access.group [[ACC_GRP97]]
// CHECK5-NEXT:    [[ADD20:%.*]] = add nsw i32 [[TMP24]], 1, !dbg [[DBG96]]
// CHECK5-NEXT:    store i32 [[ADD20]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG96]], !llvm.access.group [[ACC_GRP97]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND]], !dbg [[DBG95]], !llvm.loop [[LOOP101:![0-9]+]]
// CHECK5:       omp.inner.for.end:
// CHECK5-NEXT:    br label [[OMP_DISPATCH_INC:%.*]], !dbg [[DBG95]]
// CHECK5:       omp.dispatch.inc:
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND]], !dbg [[DBG95]], !llvm.loop [[LOOP103:![0-9]+]]
// CHECK5:       omp.dispatch.end:
// CHECK5-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB27]], i32 [[TMP5]]), !dbg [[DBG95]]
// CHECK5-NEXT:    ret void, !dbg [[DBG100]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z3foov
// CHECK5-SAME: () #[[ATTR3:[0-9]+]] !dbg [[DBG104:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    call void @_Z8mayThrowv(), !dbg [[DBG105:![0-9]+]]
// CHECK5-NEXT:    ret i32 0, !dbg [[DBG105]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z12parallel_forPfi
// CHECK5-SAME: (ptr noundef [[A:%.*]], i32 noundef [[N:%.*]]) #[[ATTR0]] !dbg [[DBG106:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[N_ADDR:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[SAVED_STACK:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[N_CASTED:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store i32 [[N]], ptr [[N_ADDR]], align 4
// CHECK5-NEXT:    [[TMP0:%.*]] = load i32, ptr [[N_ADDR]], align 4, !dbg [[DBG107:![0-9]+]]
// CHECK5-NEXT:    [[TMP1:%.*]] = zext i32 [[TMP0]] to i64, !dbg [[DBG107]]
// CHECK5-NEXT:    [[TMP2:%.*]] = call ptr @llvm.stacksave.p0(), !dbg [[DBG107]]
// CHECK5-NEXT:    store ptr [[TMP2]], ptr [[SAVED_STACK]], align 8, !dbg [[DBG107]]
// CHECK5-NEXT:    [[VLA:%.*]] = alloca float, i64 [[TMP1]], align 16, !dbg [[DBG107]]
// CHECK5-NEXT:    store i64 [[TMP1]], ptr [[__VLA_EXPR0]], align 8, !dbg [[DBG107]]
// CHECK5-NEXT:    [[TMP3:%.*]] = load i32, ptr [[N_ADDR]], align 4, !dbg [[DBG108:![0-9]+]]
// CHECK5-NEXT:    store i32 [[TMP3]], ptr [[N_CASTED]], align 4, !dbg [[DBG108]]
// CHECK5-NEXT:    [[TMP4:%.*]] = load i64, ptr [[N_CASTED]], align 8, !dbg [[DBG108]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB32:[0-9]+]], i32 3, ptr @_Z12parallel_forPfi.omp_outlined, ptr [[A_ADDR]], i64 [[TMP1]], i64 [[TMP4]]), !dbg [[DBG108]]
// CHECK5-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[SAVED_STACK]], align 8, !dbg [[DBG109:![0-9]+]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void @llvm.stackrestore.p0(ptr [[TMP5]]), !dbg [[DBG109]]
// CHECK5-NEXT:    ret void, !dbg [[DBG109]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@_Z12parallel_forPfi.omp_outlined
// CHECK5-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], i64 noundef [[VLA:%.*]], i64 noundef [[N:%.*]]) #[[ATTR1]] personality ptr @__gxx_personality_v0 !dbg [[DBG110:![0-9]+]] {
// CHECK5-NEXT:  entry:
// CHECK5-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[VLA_ADDR:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[N_ADDR:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    [[SAVED_STACK:%.*]] = alloca ptr, align 8
// CHECK5-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i64, align 8
// CHECK5-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK5-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK5-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK5-NEXT:    store i64 [[VLA]], ptr [[VLA_ADDR]], align 8
// CHECK5-NEXT:    store i64 [[N]], ptr [[N_ADDR]], align 8
// CHECK5-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !dbg [[DBG111:![0-9]+]], !nonnull [[META9]], !align [[META26]]
// CHECK5-NEXT:    [[TMP1:%.*]] = load i64, ptr [[VLA_ADDR]], align 8, !dbg [[DBG111]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison, !dbg [[DBG111]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG111]]
// CHECK5-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison, !dbg [[DBG111]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4, !dbg [[DBG111]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG112:![0-9]+]]
// CHECK5-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison, !dbg [[DBG111]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG111]]
// CHECK5-NEXT:    store i32 16908288, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison, !dbg [[DBG111]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG111]]
// CHECK5-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison, !dbg [[DBG111]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG111]]
// CHECK5-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[TMP2:%.*]] = call ptr @llvm.stacksave.p0(), !dbg [[DBG111]]
// CHECK5-NEXT:    store ptr [[TMP2]], ptr [[SAVED_STACK]], align 8, !dbg [[DBG111]]
// CHECK5-NEXT:    [[VLA5:%.*]] = alloca float, i64 [[TMP1]], align 16, !dbg [[DBG111]]
// CHECK5-NEXT:    store i64 [[TMP1]], ptr [[__VLA_EXPR0]], align 8, !dbg [[DBG111]]
// CHECK5-NEXT:    [[FREEZE_POISON6:%.*]] = freeze i32 poison, !dbg [[DBG111]]
// CHECK5-NEXT:    store i32 [[FREEZE_POISON6]], ptr [[I]], align 4, !dbg [[DBG111]]
// CHECK5-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8, !dbg [[DBG111]]
// CHECK5-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP3]], align 4, !dbg [[DBG111]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void @__kmpc_for_static_init_4u(ptr @[[GLOB29:[0-9]+]], i32 [[TMP4]], i32 33, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 5), !dbg [[DBG111]]
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND:%.*]], !dbg [[DBG111]]
// CHECK5:       omp.dispatch.cond:
// CHECK5-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[TMP5]], 16908288, !dbg [[DBG112]]
// CHECK5-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]], !dbg [[DBG112]]
// CHECK5:       cond.true:
// CHECK5-NEXT:    br label [[COND_END:%.*]], !dbg [[DBG112]]
// CHECK5:       cond.false:
// CHECK5-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    br label [[COND_END]], !dbg [[DBG112]]
// CHECK5:       cond.end:
// CHECK5-NEXT:    [[COND:%.*]] = phi i32 [ 16908288, [[COND_TRUE]] ], [ [[TMP6]], [[COND_FALSE]] ], !dbg [[DBG112]]
// CHECK5-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    store i32 [[TMP7]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[CMP7:%.*]] = icmp ule i32 [[TMP8]], [[TMP9]], !dbg [[DBG112]]
// CHECK5-NEXT:    br i1 [[CMP7]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_CLEANUP:%.*]], !dbg [[DBG111]]
// CHECK5:       omp.dispatch.cleanup:
// CHECK5-NEXT:    br label [[OMP_DISPATCH_END:%.*]], !dbg [[DBG111]]
// CHECK5:       omp.dispatch.body:
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]], !dbg [[DBG111]]
// CHECK5:       omp.inner.for.cond:
// CHECK5-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[CMP8:%.*]] = icmp ule i32 [[TMP10]], [[TMP11]], !dbg [[DBG112]]
// CHECK5-NEXT:    br i1 [[CMP8]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_COND_CLEANUP:%.*]], !dbg [[DBG111]]
// CHECK5:       omp.inner.for.cond.cleanup:
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_END:%.*]], !dbg [[DBG111]]
// CHECK5:       omp.inner.for.body:
// CHECK5-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[MUL:%.*]] = mul i32 [[TMP12]], 127, !dbg [[DBG112]]
// CHECK5-NEXT:    [[ADD:%.*]] = add i32 131071, [[MUL]], !dbg [[DBG112]]
// CHECK5-NEXT:    store i32 [[ADD]], ptr [[I]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[CALL:%.*]] = invoke noundef i32 @_Z3foov()
// CHECK5-NEXT:            to label [[INVOKE_CONT:%.*]] unwind label [[TERMINATE_LPAD:%.*]], !dbg [[DBG113:![0-9]+]]
// CHECK5:       invoke.cont:
// CHECK5-NEXT:    [[CONV:%.*]] = sitofp i32 [[CALL]] to float, !dbg [[DBG113]]
// CHECK5-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG113]]
// CHECK5-NEXT:    [[IDXPROM:%.*]] = zext i32 [[TMP13]] to i64, !dbg [[DBG113]]
// CHECK5-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[VLA5]], i64 [[IDXPROM]], !dbg [[DBG113]]
// CHECK5-NEXT:    [[TMP14:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !dbg [[DBG113]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[ADD9:%.*]] = fadd float [[CONV]], [[TMP14]], !dbg [[DBG113]]
// CHECK5-NEXT:    [[TMP15:%.*]] = load i32, ptr [[N_ADDR]], align 4, !dbg [[DBG113]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[CONV10:%.*]] = sitofp i32 [[TMP15]] to float, !dbg [[DBG113]]
// CHECK5-NEXT:    [[ADD11:%.*]] = fadd float [[ADD9]], [[CONV10]], !dbg [[DBG113]]
// CHECK5-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[TMP0]], align 8, !dbg [[DBG113]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[TMP17:%.*]] = load i32, ptr [[I]], align 4, !dbg [[DBG113]]
// CHECK5-NEXT:    [[IDXPROM12:%.*]] = zext i32 [[TMP17]] to i64, !dbg [[DBG113]]
// CHECK5-NEXT:    [[ARRAYIDX13:%.*]] = getelementptr inbounds nuw float, ptr [[TMP16]], i64 [[IDXPROM12]], !dbg [[DBG113]]
// CHECK5-NEXT:    [[TMP18:%.*]] = load float, ptr [[ARRAYIDX13]], align 4, !dbg [[DBG113]], !freeze_bits [[META9]]
// CHECK5-NEXT:    [[ADD14:%.*]] = fadd float [[TMP18]], [[ADD11]], !dbg [[DBG113]]
// CHECK5-NEXT:    store float [[ADD14]], ptr [[ARRAYIDX13]], align 4, !dbg [[DBG113]]
// CHECK5-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]], !dbg [[DBG113]]
// CHECK5:       omp.body.continue:
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]], !dbg [[DBG111]]
// CHECK5:       omp.inner.for.inc:
// CHECK5-NEXT:    [[TMP19:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[ADD15:%.*]] = add i32 [[TMP19]], 1, !dbg [[DBG112]]
// CHECK5-NEXT:    store i32 [[ADD15]], ptr [[DOTOMP_IV]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    br label [[OMP_INNER_FOR_COND]], !dbg [[DBG111]], !llvm.loop [[LOOP114:![0-9]+]]
// CHECK5:       omp.inner.for.end:
// CHECK5-NEXT:    br label [[OMP_DISPATCH_INC:%.*]], !dbg [[DBG111]]
// CHECK5:       omp.dispatch.inc:
// CHECK5-NEXT:    [[TMP20:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[TMP21:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[ADD16:%.*]] = add i32 [[TMP20]], [[TMP21]], !dbg [[DBG112]]
// CHECK5-NEXT:    store i32 [[ADD16]], ptr [[DOTOMP_LB]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[TMP22:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[TMP23:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    [[ADD17:%.*]] = add i32 [[TMP22]], [[TMP23]], !dbg [[DBG112]]
// CHECK5-NEXT:    store i32 [[ADD17]], ptr [[DOTOMP_UB]], align 4, !dbg [[DBG112]]
// CHECK5-NEXT:    br label [[OMP_DISPATCH_COND]], !dbg [[DBG111]], !llvm.loop [[LOOP115:![0-9]+]]
// CHECK5:       omp.dispatch.end:
// CHECK5-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB31:[0-9]+]], i32 [[TMP4]]), !dbg [[DBG111]]
// CHECK5-NEXT:    [[TMP24:%.*]] = load ptr, ptr [[SAVED_STACK]], align 8, !dbg [[DBG111]], !freeze_bits [[META9]]
// CHECK5-NEXT:    call void @llvm.stackrestore.p0(ptr [[TMP24]]), !dbg [[DBG111]]
// CHECK5-NEXT:    ret void, !dbg [[DBG113]]
// CHECK5:       terminate.lpad:
// CHECK5-NEXT:    [[TMP25:%.*]] = landingpad { ptr, i32 }
// CHECK5-NEXT:            catch ptr null, !dbg [[DBG113]]
// CHECK5-NEXT:    [[TMP26:%.*]] = extractvalue { ptr, i32 } [[TMP25]], 0, !dbg [[DBG113]]
// CHECK5-NEXT:    call void @__clang_call_terminate(ptr [[TMP26]]) #[[ATTR7:[0-9]+]], !dbg [[DBG113]]
// CHECK5-NEXT:    unreachable, !dbg [[DBG113]]
//
//
// CHECK5-LABEL: define {{[^@]+}}@__clang_call_terminate
// CHECK5-SAME: (ptr noundef [[TMP0:%.*]]) #[[ATTR6:[0-9]+]] {
// CHECK5-NEXT:    [[TMP2:%.*]] = call ptr @__cxa_begin_catch(ptr [[TMP0]]) #[[ATTR2:[0-9]+]]
// CHECK5-NEXT:    call void @_ZSt9terminatev() #[[ATTR7]]
// CHECK5-NEXT:    unreachable
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z17with_var_schedulev
// CHECK6-SAME: () #[[ATTR0:[0-9]+]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[A:%.*]] = alloca double, align 8
// CHECK6-NEXT:    [[DOTCAPTURE_EXPR_:%.*]] = alloca i8, align 1
// CHECK6-NEXT:    [[DOTCAPTURE_EXPR__CASTED:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[FREEZE_POISON:%.*]] = freeze double poison
// CHECK6-NEXT:    store double [[FREEZE_POISON]], ptr [[A]], align 8
// CHECK6-NEXT:    store double 5.000000e+00, ptr [[A]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i8 poison
// CHECK6-NEXT:    store i8 [[FREEZE_POISON1]], ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK6-NEXT:    [[TMP0:%.*]] = load double, ptr [[A]], align 8
// CHECK6-NEXT:    [[CONV:%.*]] = fptosi double [[TMP0]] to i8
// CHECK6-NEXT:    store i8 [[CONV]], ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK6-NEXT:    [[TMP1:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK6-NEXT:    store i8 [[TMP1]], ptr [[DOTCAPTURE_EXPR__CASTED]], align 1
// CHECK6-NEXT:    [[TMP2:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR__CASTED]], align 8, !freeze_bits [[META3:![0-9]+]]
// CHECK6-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2:[0-9]+]], i32 1, ptr @_Z17with_var_schedulev.omp_outlined, i64 [[TMP2]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z17with_var_schedulev.omp_outlined
// CHECK6-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], i64 noundef [[DOTCAPTURE_EXPR_:%.*]]) #[[ATTR1:[0-9]+]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTCAPTURE_EXPR__ADDR:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[TMP:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTCAPTURE_EXPR_1:%.*]] = alloca double, align 8
// CHECK6-NEXT:    [[DOTCAPTURE_EXPR_3:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[I:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[A:%.*]] = alloca double, align 8
// CHECK6-NEXT:    [[I12:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK6-NEXT:    store i64 [[DOTCAPTURE_EXPR_]], ptr [[DOTCAPTURE_EXPR__ADDR]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON2:%.*]] = freeze double poison
// CHECK6-NEXT:    store double [[FREEZE_POISON2]], ptr [[DOTCAPTURE_EXPR_1]], align 8
// CHECK6-NEXT:    [[TMP0:%.*]] = load double, ptr undef, align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[ADD:%.*]] = fadd double 2.000000e+00, [[TMP0]]
// CHECK6-NEXT:    store double [[ADD]], ptr [[DOTCAPTURE_EXPR_1]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON4]], ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK6-NEXT:    [[TMP1:%.*]] = load double, ptr [[DOTCAPTURE_EXPR_1]], align 8
// CHECK6-NEXT:    [[SUB:%.*]] = fsub double [[TMP1]], 1.000000e+00
// CHECK6-NEXT:    [[DIV:%.*]] = fdiv double [[SUB]], 1.000000e+00
// CHECK6-NEXT:    [[CONV:%.*]] = fptoui double [[DIV]] to i64
// CHECK6-NEXT:    [[SUB5:%.*]] = sub i64 [[CONV]], 1
// CHECK6-NEXT:    store i64 [[SUB5]], ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON6:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON6]], ptr [[I]], align 8
// CHECK6-NEXT:    store i64 1, ptr [[I]], align 8
// CHECK6-NEXT:    [[TMP2:%.*]] = load double, ptr [[DOTCAPTURE_EXPR_1]], align 8
// CHECK6-NEXT:    [[CMP:%.*]] = fcmp olt double 1.000000e+00, [[TMP2]]
// CHECK6-NEXT:    br i1 [[CMP]], label [[OMP_PRECOND_THEN:%.*]], label [[OMP_PRECOND_END:%.*]]
// CHECK6:       omp.precond.then:
// CHECK6-NEXT:    [[FREEZE_POISON7:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON7]], ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON8:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON8]], ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    [[TMP3:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK6-NEXT:    store i64 [[TMP3]], ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON9:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON9]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK6-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON10:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON10]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON11:%.*]] = freeze double poison
// CHECK6-NEXT:    store double [[FREEZE_POISON11]], ptr [[A]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON13:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON13]], ptr [[I12]], align 8
// CHECK6-NEXT:    [[TMP4:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR__ADDR]], align 1, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[CONV14:%.*]] = sext i8 [[TMP4]] to i64
// CHECK6-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    [[TMP6:%.*]] = load i32, ptr [[TMP5]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void @__kmpc_for_static_init_8u(ptr @[[GLOB1:[0-9]+]], i32 [[TMP6]], i32 33, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i64 1, i64 [[CONV14]])
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK6:       omp.dispatch.cond:
// CHECK6-NEXT:    [[TMP7:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    [[TMP8:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK6-NEXT:    [[CMP15:%.*]] = icmp ugt i64 [[TMP7]], [[TMP8]]
// CHECK6-NEXT:    br i1 [[CMP15]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK6:       cond.true:
// CHECK6-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK6-NEXT:    br label [[COND_END:%.*]]
// CHECK6:       cond.false:
// CHECK6-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    br label [[COND_END]]
// CHECK6:       cond.end:
// CHECK6-NEXT:    [[COND:%.*]] = phi i64 [ [[TMP9]], [[COND_TRUE]] ], [ [[TMP10]], [[COND_FALSE]] ]
// CHECK6-NEXT:    store i64 [[COND]], ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    [[TMP11:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    store i64 [[TMP11]], ptr [[DOTOMP_IV]], align 8
// CHECK6-NEXT:    [[TMP12:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK6-NEXT:    [[TMP13:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    [[ADD16:%.*]] = add i64 [[TMP13]], 1
// CHECK6-NEXT:    [[CMP17:%.*]] = icmp ult i64 [[TMP12]], [[ADD16]]
// CHECK6-NEXT:    br i1 [[CMP17]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK6:       omp.dispatch.body:
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK6:       omp.inner.for.cond:
// CHECK6-NEXT:    [[TMP14:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK6-NEXT:    [[TMP15:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    [[ADD18:%.*]] = add i64 [[TMP15]], 1
// CHECK6-NEXT:    [[CMP19:%.*]] = icmp ult i64 [[TMP14]], [[ADD18]]
// CHECK6-NEXT:    br i1 [[CMP19]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK6:       omp.inner.for.body:
// CHECK6-NEXT:    [[TMP16:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK6-NEXT:    [[MUL:%.*]] = mul i64 [[TMP16]], 1
// CHECK6-NEXT:    [[ADD20:%.*]] = add i64 1, [[MUL]]
// CHECK6-NEXT:    store i64 [[ADD20]], ptr [[I12]], align 8
// CHECK6-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK6:       omp.body.continue:
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK6:       omp.inner.for.inc:
// CHECK6-NEXT:    [[TMP17:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK6-NEXT:    [[ADD21:%.*]] = add i64 [[TMP17]], 1
// CHECK6-NEXT:    store i64 [[ADD21]], ptr [[DOTOMP_IV]], align 8
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK6:       omp.inner.for.end:
// CHECK6-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK6:       omp.dispatch.inc:
// CHECK6-NEXT:    [[TMP18:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    [[TMP19:%.*]] = load i64, ptr [[DOTOMP_STRIDE]], align 8
// CHECK6-NEXT:    [[ADD22:%.*]] = add i64 [[TMP18]], [[TMP19]]
// CHECK6-NEXT:    store i64 [[ADD22]], ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    [[TMP20:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    [[TMP21:%.*]] = load i64, ptr [[DOTOMP_STRIDE]], align 8
// CHECK6-NEXT:    [[ADD23:%.*]] = add i64 [[TMP20]], [[TMP21]]
// CHECK6-NEXT:    store i64 [[ADD23]], ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK6:       omp.dispatch.end:
// CHECK6-NEXT:    [[TMP22:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    [[TMP23:%.*]] = load i32, ptr [[TMP22]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP23]])
// CHECK6-NEXT:    br label [[OMP_PRECOND_END]]
// CHECK6:       omp.precond.end:
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z23without_schedule_clausePfS_S_S_
// CHECK6-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z23without_schedule_clausePfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z23without_schedule_clausePfS_S_S_.omp_outlined
// CHECK6-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6:![0-9]+]]
// CHECK6-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    store i32 4571423, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[I]], align 4
// CHECK6-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB1]], i32 [[TMP5]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1)
// CHECK6-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP6]], 4571423
// CHECK6-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK6:       cond.true:
// CHECK6-NEXT:    br label [[COND_END:%.*]]
// CHECK6:       cond.false:
// CHECK6-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    br label [[COND_END]]
// CHECK6:       cond.end:
// CHECK6-NEXT:    [[COND:%.*]] = phi i32 [ 4571423, [[COND_TRUE]] ], [ [[TMP7]], [[COND_FALSE]] ]
// CHECK6-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    store i32 [[TMP8]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK6:       omp.inner.for.cond:
// CHECK6-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[CMP6:%.*]] = icmp sle i32 [[TMP9]], [[TMP10]]
// CHECK6-NEXT:    br i1 [[CMP6]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK6:       omp.inner.for.body:
// CHECK6-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP11]], 7
// CHECK6-NEXT:    [[ADD:%.*]] = add nsw i32 33, [[MUL]]
// CHECK6-NEXT:    store i32 [[ADD]], ptr [[I]], align 4
// CHECK6-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[TMP1]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP13]] to i64
// CHECK6-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[TMP12]], i64 [[IDXPROM]]
// CHECK6-NEXT:    [[TMP14:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[TMP2]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP16:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM7:%.*]] = sext i32 [[TMP16]] to i64
// CHECK6-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[TMP15]], i64 [[IDXPROM7]]
// CHECK6-NEXT:    [[TMP17:%.*]] = load float, ptr [[ARRAYIDX8]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL9:%.*]] = fmul float [[TMP14]], [[TMP17]]
// CHECK6-NEXT:    [[TMP18:%.*]] = load ptr, ptr [[TMP3]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP19:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM10:%.*]] = sext i32 [[TMP19]] to i64
// CHECK6-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds float, ptr [[TMP18]], i64 [[IDXPROM10]]
// CHECK6-NEXT:    [[TMP20:%.*]] = load float, ptr [[ARRAYIDX11]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL12:%.*]] = fmul float [[MUL9]], [[TMP20]]
// CHECK6-NEXT:    [[TMP21:%.*]] = load ptr, ptr [[TMP0]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP22:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM13:%.*]] = sext i32 [[TMP22]] to i64
// CHECK6-NEXT:    [[ARRAYIDX14:%.*]] = getelementptr inbounds float, ptr [[TMP21]], i64 [[IDXPROM13]]
// CHECK6-NEXT:    store float [[MUL12]], ptr [[ARRAYIDX14]], align 4
// CHECK6-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK6:       omp.body.continue:
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK6:       omp.inner.for.inc:
// CHECK6-NEXT:    [[TMP23:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[ADD15:%.*]] = add nsw i32 [[TMP23]], 1
// CHECK6-NEXT:    store i32 [[ADD15]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK6:       omp.inner.for.end:
// CHECK6-NEXT:    br label [[OMP_LOOP_EXIT:%.*]]
// CHECK6:       omp.loop.exit:
// CHECK6-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP5]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z18static_not_chunkedPfS_S_S_
// CHECK6-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z18static_not_chunkedPfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z18static_not_chunkedPfS_S_S_.omp_outlined
// CHECK6-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    store i32 4571423, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[I]], align 4
// CHECK6-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB1]], i32 [[TMP5]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1)
// CHECK6-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP6]], 4571423
// CHECK6-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK6:       cond.true:
// CHECK6-NEXT:    br label [[COND_END:%.*]]
// CHECK6:       cond.false:
// CHECK6-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    br label [[COND_END]]
// CHECK6:       cond.end:
// CHECK6-NEXT:    [[COND:%.*]] = phi i32 [ 4571423, [[COND_TRUE]] ], [ [[TMP7]], [[COND_FALSE]] ]
// CHECK6-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    store i32 [[TMP8]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK6:       omp.inner.for.cond:
// CHECK6-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[CMP6:%.*]] = icmp sle i32 [[TMP9]], [[TMP10]]
// CHECK6-NEXT:    br i1 [[CMP6]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK6:       omp.inner.for.body:
// CHECK6-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP11]], 7
// CHECK6-NEXT:    [[SUB:%.*]] = sub nsw i32 32000000, [[MUL]]
// CHECK6-NEXT:    store i32 [[SUB]], ptr [[I]], align 4
// CHECK6-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[TMP1]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM:%.*]] = sext i32 [[TMP13]] to i64
// CHECK6-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[TMP12]], i64 [[IDXPROM]]
// CHECK6-NEXT:    [[TMP14:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[TMP2]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP16:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM7:%.*]] = sext i32 [[TMP16]] to i64
// CHECK6-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds float, ptr [[TMP15]], i64 [[IDXPROM7]]
// CHECK6-NEXT:    [[TMP17:%.*]] = load float, ptr [[ARRAYIDX8]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL9:%.*]] = fmul float [[TMP14]], [[TMP17]]
// CHECK6-NEXT:    [[TMP18:%.*]] = load ptr, ptr [[TMP3]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP19:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM10:%.*]] = sext i32 [[TMP19]] to i64
// CHECK6-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds float, ptr [[TMP18]], i64 [[IDXPROM10]]
// CHECK6-NEXT:    [[TMP20:%.*]] = load float, ptr [[ARRAYIDX11]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL12:%.*]] = fmul float [[MUL9]], [[TMP20]]
// CHECK6-NEXT:    [[TMP21:%.*]] = load ptr, ptr [[TMP0]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP22:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM13:%.*]] = sext i32 [[TMP22]] to i64
// CHECK6-NEXT:    [[ARRAYIDX14:%.*]] = getelementptr inbounds float, ptr [[TMP21]], i64 [[IDXPROM13]]
// CHECK6-NEXT:    store float [[MUL12]], ptr [[ARRAYIDX14]], align 4
// CHECK6-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK6:       omp.body.continue:
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK6:       omp.inner.for.inc:
// CHECK6-NEXT:    [[TMP23:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP23]], 1
// CHECK6-NEXT:    store i32 [[ADD]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK6:       omp.inner.for.end:
// CHECK6-NEXT:    br label [[OMP_LOOP_EXIT:%.*]]
// CHECK6:       omp.loop.exit:
// CHECK6-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP5]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z14static_chunkedPfS_S_S_
// CHECK6-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z14static_chunkedPfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z14static_chunkedPfS_S_S_.omp_outlined
// CHECK6-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    store i32 16908288, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[I]], align 4
// CHECK6-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void @__kmpc_for_static_init_4u(ptr @[[GLOB1]], i32 [[TMP5]], i32 33, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 5)
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK6:       omp.dispatch.cond:
// CHECK6-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[TMP6]], 16908288
// CHECK6-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK6:       cond.true:
// CHECK6-NEXT:    br label [[COND_END:%.*]]
// CHECK6:       cond.false:
// CHECK6-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    br label [[COND_END]]
// CHECK6:       cond.end:
// CHECK6-NEXT:    [[COND:%.*]] = phi i32 [ 16908288, [[COND_TRUE]] ], [ [[TMP7]], [[COND_FALSE]] ]
// CHECK6-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    store i32 [[TMP8]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[CMP6:%.*]] = icmp ule i32 [[TMP9]], [[TMP10]]
// CHECK6-NEXT:    br i1 [[CMP6]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK6:       omp.dispatch.body:
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK6:       omp.inner.for.cond:
// CHECK6-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[CMP7:%.*]] = icmp ule i32 [[TMP11]], [[TMP12]]
// CHECK6-NEXT:    br i1 [[CMP7]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK6:       omp.inner.for.body:
// CHECK6-NEXT:    [[TMP13:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[MUL:%.*]] = mul i32 [[TMP13]], 127
// CHECK6-NEXT:    [[ADD:%.*]] = add i32 131071, [[MUL]]
// CHECK6-NEXT:    store i32 [[ADD]], ptr [[I]], align 4
// CHECK6-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP1]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP15:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM:%.*]] = zext i32 [[TMP15]] to i64
// CHECK6-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP14]], i64 [[IDXPROM]]
// CHECK6-NEXT:    [[TMP16:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP2]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP18:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM8:%.*]] = zext i32 [[TMP18]] to i64
// CHECK6-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds nuw float, ptr [[TMP17]], i64 [[IDXPROM8]]
// CHECK6-NEXT:    [[TMP19:%.*]] = load float, ptr [[ARRAYIDX9]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL10:%.*]] = fmul float [[TMP16]], [[TMP19]]
// CHECK6-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[TMP3]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP21:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM11:%.*]] = zext i32 [[TMP21]] to i64
// CHECK6-NEXT:    [[ARRAYIDX12:%.*]] = getelementptr inbounds nuw float, ptr [[TMP20]], i64 [[IDXPROM11]]
// CHECK6-NEXT:    [[TMP22:%.*]] = load float, ptr [[ARRAYIDX12]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL13:%.*]] = fmul float [[MUL10]], [[TMP22]]
// CHECK6-NEXT:    [[TMP23:%.*]] = load ptr, ptr [[TMP0]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP24:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM14:%.*]] = zext i32 [[TMP24]] to i64
// CHECK6-NEXT:    [[ARRAYIDX15:%.*]] = getelementptr inbounds nuw float, ptr [[TMP23]], i64 [[IDXPROM14]]
// CHECK6-NEXT:    store float [[MUL13]], ptr [[ARRAYIDX15]], align 4
// CHECK6-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK6:       omp.body.continue:
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK6:       omp.inner.for.inc:
// CHECK6-NEXT:    [[TMP25:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[ADD16:%.*]] = add i32 [[TMP25]], 1
// CHECK6-NEXT:    store i32 [[ADD16]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK6:       omp.inner.for.end:
// CHECK6-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK6:       omp.dispatch.inc:
// CHECK6-NEXT:    [[TMP26:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    [[TMP27:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    [[ADD17:%.*]] = add i32 [[TMP26]], [[TMP27]]
// CHECK6-NEXT:    store i32 [[ADD17]], ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    [[TMP28:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[TMP29:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    [[ADD18:%.*]] = add i32 [[TMP28]], [[TMP29]]
// CHECK6-NEXT:    store i32 [[ADD18]], ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK6:       omp.dispatch.end:
// CHECK6-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP5]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z8dynamic1PfS_S_S_
// CHECK6-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z8dynamic1PfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z8dynamic1PfS_S_S_.omp_outlined
// CHECK6-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[TMP:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[I:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    store i64 16908287, ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK6-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON5]], ptr [[I]], align 8
// CHECK6-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void @__kmpc_dispatch_init_8u(ptr @[[GLOB2]], i32 [[TMP5]], i32 1073741859, i64 0, i64 16908287, i64 1, i64 1)
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK6:       omp.dispatch.cond:
// CHECK6-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_dispatch_next_8u(ptr @[[GLOB2]], i32 [[TMP5]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]])
// CHECK6-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP6]], 0
// CHECK6-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK6:       omp.dispatch.body:
// CHECK6-NEXT:    [[TMP7:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    store i64 [[TMP7]], ptr [[DOTOMP_IV]], align 8
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK6:       omp.inner.for.cond:
// CHECK6-NEXT:    [[TMP8:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP7:![0-9]+]]
// CHECK6-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK6-NEXT:    [[ADD:%.*]] = add i64 [[TMP9]], 1
// CHECK6-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TMP8]], [[ADD]]
// CHECK6-NEXT:    br i1 [[CMP]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK6:       omp.inner.for.body:
// CHECK6-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK6-NEXT:    [[MUL:%.*]] = mul i64 [[TMP10]], 127
// CHECK6-NEXT:    [[ADD6:%.*]] = add i64 131071, [[MUL]]
// CHECK6-NEXT:    store i64 [[ADD6]], ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK6-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[TMP1]], align 8, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP12:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK6-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP11]], i64 [[TMP12]]
// CHECK6-NEXT:    [[TMP13:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP2]], align 8, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP15:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK6-NEXT:    [[ARRAYIDX7:%.*]] = getelementptr inbounds nuw float, ptr [[TMP14]], i64 [[TMP15]]
// CHECK6-NEXT:    [[TMP16:%.*]] = load float, ptr [[ARRAYIDX7]], align 4, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL8:%.*]] = fmul float [[TMP13]], [[TMP16]]
// CHECK6-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP3]], align 8, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP18:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK6-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds nuw float, ptr [[TMP17]], i64 [[TMP18]]
// CHECK6-NEXT:    [[TMP19:%.*]] = load float, ptr [[ARRAYIDX9]], align 4, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL10:%.*]] = fmul float [[MUL8]], [[TMP19]]
// CHECK6-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[TMP0]], align 8, !llvm.access.group [[ACC_GRP7]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP21:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK6-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds nuw float, ptr [[TMP20]], i64 [[TMP21]]
// CHECK6-NEXT:    store float [[MUL10]], ptr [[ARRAYIDX11]], align 4, !llvm.access.group [[ACC_GRP7]]
// CHECK6-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK6:       omp.body.continue:
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK6:       omp.inner.for.inc:
// CHECK6-NEXT:    [[TMP22:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK6-NEXT:    [[ADD12:%.*]] = add i64 [[TMP22]], 1
// CHECK6-NEXT:    store i64 [[ADD12]], ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP7]]
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND]], !llvm.loop [[LOOP8:![0-9]+]]
// CHECK6:       omp.inner.for.end:
// CHECK6-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK6:       omp.dispatch.inc:
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK6:       omp.dispatch.end:
// CHECK6-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB2]], i32 [[TMP5]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z7guided7PfS_S_S_
// CHECK6-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z7guided7PfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z7guided7PfS_S_S_.omp_outlined
// CHECK6-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[TMP:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[I:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    store i64 16908287, ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK6-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON5]], ptr [[I]], align 8
// CHECK6-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void @__kmpc_dispatch_init_8u(ptr @[[GLOB2]], i32 [[TMP5]], i32 1073741860, i64 0, i64 16908287, i64 1, i64 7)
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK6:       omp.dispatch.cond:
// CHECK6-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_dispatch_next_8u(ptr @[[GLOB2]], i32 [[TMP5]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]])
// CHECK6-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP6]], 0
// CHECK6-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK6:       omp.dispatch.body:
// CHECK6-NEXT:    [[TMP7:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    store i64 [[TMP7]], ptr [[DOTOMP_IV]], align 8
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK6:       omp.inner.for.cond:
// CHECK6-NEXT:    [[TMP8:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP10:![0-9]+]]
// CHECK6-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK6-NEXT:    [[ADD:%.*]] = add i64 [[TMP9]], 1
// CHECK6-NEXT:    [[CMP:%.*]] = icmp ult i64 [[TMP8]], [[ADD]]
// CHECK6-NEXT:    br i1 [[CMP]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK6:       omp.inner.for.body:
// CHECK6-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK6-NEXT:    [[MUL:%.*]] = mul i64 [[TMP10]], 127
// CHECK6-NEXT:    [[ADD6:%.*]] = add i64 131071, [[MUL]]
// CHECK6-NEXT:    store i64 [[ADD6]], ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK6-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[TMP1]], align 8, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP12:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK6-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP11]], i64 [[TMP12]]
// CHECK6-NEXT:    [[TMP13:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[TMP2]], align 8, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP15:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK6-NEXT:    [[ARRAYIDX7:%.*]] = getelementptr inbounds nuw float, ptr [[TMP14]], i64 [[TMP15]]
// CHECK6-NEXT:    [[TMP16:%.*]] = load float, ptr [[ARRAYIDX7]], align 4, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL8:%.*]] = fmul float [[TMP13]], [[TMP16]]
// CHECK6-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[TMP3]], align 8, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP18:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK6-NEXT:    [[ARRAYIDX9:%.*]] = getelementptr inbounds nuw float, ptr [[TMP17]], i64 [[TMP18]]
// CHECK6-NEXT:    [[TMP19:%.*]] = load float, ptr [[ARRAYIDX9]], align 4, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL10:%.*]] = fmul float [[MUL8]], [[TMP19]]
// CHECK6-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[TMP0]], align 8, !llvm.access.group [[ACC_GRP10]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP21:%.*]] = load i64, ptr [[I]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK6-NEXT:    [[ARRAYIDX11:%.*]] = getelementptr inbounds nuw float, ptr [[TMP20]], i64 [[TMP21]]
// CHECK6-NEXT:    store float [[MUL10]], ptr [[ARRAYIDX11]], align 4, !llvm.access.group [[ACC_GRP10]]
// CHECK6-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK6:       omp.body.continue:
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK6:       omp.inner.for.inc:
// CHECK6-NEXT:    [[TMP22:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK6-NEXT:    [[ADD12:%.*]] = add i64 [[TMP22]], 1
// CHECK6-NEXT:    store i64 [[ADD12]], ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP10]]
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND]], !llvm.loop [[LOOP11:![0-9]+]]
// CHECK6:       omp.inner.for.end:
// CHECK6-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK6:       omp.dispatch.inc:
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK6:       omp.dispatch.end:
// CHECK6-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB2]], i32 [[TMP5]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z9test_autoPfS_S_S_
// CHECK6-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[Y:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON]], ptr [[X]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[X]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[Y]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[Y]], align 4
// CHECK6-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 5, ptr @_Z9test_autoPfS_S_S_.omp_outlined, ptr [[Y]], ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z9test_autoPfS_S_S_.omp_outlined
// CHECK6-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 4 dereferenceable(4) [[Y:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[Y_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[TMP:%.*]] = alloca i8, align 1
// CHECK6-NEXT:    [[_TMP1:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTCAPTURE_EXPR_:%.*]] = alloca i8, align 1
// CHECK6-NEXT:    [[DOTCAPTURE_EXPR_3:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[I:%.*]] = alloca i8, align 1
// CHECK6-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[I15:%.*]] = alloca i8, align 1
// CHECK6-NEXT:    [[X17:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[Y]], ptr [[Y_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[Y_ADDR]], align 8, !nonnull [[META3]], !align [[META13:![0-9]+]]
// CHECK6-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i8 poison
// CHECK6-NEXT:    store i8 [[FREEZE_POISON2]], ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK6-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP0]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[CONV:%.*]] = trunc i32 [[TMP5]] to i8
// CHECK6-NEXT:    store i8 [[CONV]], ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK6-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON4]], ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK6-NEXT:    [[TMP6:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK6-NEXT:    [[CONV5:%.*]] = sext i8 [[TMP6]] to i32
// CHECK6-NEXT:    [[SUB:%.*]] = sub i32 57, [[CONV5]]
// CHECK6-NEXT:    [[ADD:%.*]] = add i32 [[SUB]], 1
// CHECK6-NEXT:    [[DIV:%.*]] = udiv i32 [[ADD]], 1
// CHECK6-NEXT:    [[CONV6:%.*]] = zext i32 [[DIV]] to i64
// CHECK6-NEXT:    [[MUL:%.*]] = mul nsw i64 [[CONV6]], 11
// CHECK6-NEXT:    [[SUB7:%.*]] = sub nsw i64 [[MUL]], 1
// CHECK6-NEXT:    store i64 [[SUB7]], ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON8:%.*]] = freeze i8 poison
// CHECK6-NEXT:    store i8 [[FREEZE_POISON8]], ptr [[I]], align 1
// CHECK6-NEXT:    [[FREEZE_POISON9:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON9]], ptr [[X]], align 4
// CHECK6-NEXT:    [[TMP7:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK6-NEXT:    store i8 [[TMP7]], ptr [[I]], align 1
// CHECK6-NEXT:    store i32 11, ptr [[X]], align 4
// CHECK6-NEXT:    [[TMP8:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1
// CHECK6-NEXT:    [[CONV10:%.*]] = sext i8 [[TMP8]] to i32
// CHECK6-NEXT:    [[CMP:%.*]] = icmp sle i32 [[CONV10]], 57
// CHECK6-NEXT:    br i1 [[CMP]], label [[OMP_PRECOND_THEN:%.*]], label [[OMP_PRECOND_END:%.*]]
// CHECK6:       omp.precond.then:
// CHECK6-NEXT:    [[FREEZE_POISON11:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON11]], ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON12:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON12]], ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK6-NEXT:    store i64 [[TMP9]], ptr [[DOTOMP_UB]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON13:%.*]] = freeze i64 poison
// CHECK6-NEXT:    store i64 [[FREEZE_POISON13]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK6-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON14:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON14]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON16:%.*]] = freeze i8 poison
// CHECK6-NEXT:    store i8 [[FREEZE_POISON16]], ptr [[I15]], align 1
// CHECK6-NEXT:    [[FREEZE_POISON18:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON18]], ptr [[X17]], align 4
// CHECK6-NEXT:    [[TMP10:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_3]], align 8
// CHECK6-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    [[TMP12:%.*]] = load i32, ptr [[TMP11]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void @__kmpc_dispatch_init_8(ptr @[[GLOB2]], i32 [[TMP12]], i32 1073741862, i64 0, i64 [[TMP10]], i64 1, i64 1)
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK6:       omp.dispatch.cond:
// CHECK6-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    [[TMP14:%.*]] = load i32, ptr [[TMP13]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP15:%.*]] = call i32 @__kmpc_dispatch_next_8(ptr @[[GLOB2]], i32 [[TMP14]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]])
// CHECK6-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP15]], 0
// CHECK6-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK6:       omp.dispatch.body:
// CHECK6-NEXT:    [[TMP16:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK6-NEXT:    store i64 [[TMP16]], ptr [[DOTOMP_IV]], align 8
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK6:       omp.inner.for.cond:
// CHECK6-NEXT:    [[TMP17:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14:![0-9]+]]
// CHECK6-NEXT:    [[TMP18:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    [[CMP19:%.*]] = icmp sle i64 [[TMP17]], [[TMP18]]
// CHECK6-NEXT:    br i1 [[CMP19]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK6:       omp.inner.for.body:
// CHECK6-NEXT:    [[TMP19:%.*]] = load i8, ptr [[DOTCAPTURE_EXPR_]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    [[CONV20:%.*]] = sext i8 [[TMP19]] to i64
// CHECK6-NEXT:    [[TMP20:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    [[DIV21:%.*]] = sdiv i64 [[TMP20]], 11
// CHECK6-NEXT:    [[MUL22:%.*]] = mul nsw i64 [[DIV21]], 1
// CHECK6-NEXT:    [[ADD23:%.*]] = add nsw i64 [[CONV20]], [[MUL22]]
// CHECK6-NEXT:    [[CONV24:%.*]] = trunc i64 [[ADD23]] to i8
// CHECK6-NEXT:    store i8 [[CONV24]], ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    [[TMP21:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    [[TMP22:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    [[DIV25:%.*]] = sdiv i64 [[TMP22]], 11
// CHECK6-NEXT:    [[MUL26:%.*]] = mul nsw i64 [[DIV25]], 11
// CHECK6-NEXT:    [[SUB27:%.*]] = sub nsw i64 [[TMP21]], [[MUL26]]
// CHECK6-NEXT:    [[MUL28:%.*]] = mul nsw i64 [[SUB27]], 1
// CHECK6-NEXT:    [[SUB29:%.*]] = sub nsw i64 11, [[MUL28]]
// CHECK6-NEXT:    [[CONV30:%.*]] = trunc i64 [[SUB29]] to i32
// CHECK6-NEXT:    store i32 [[CONV30]], ptr [[X17]], align 4, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    [[TMP23:%.*]] = load ptr, ptr [[TMP2]], align 8, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP24:%.*]] = load i8, ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    [[IDXPROM:%.*]] = sext i8 [[TMP24]] to i64
// CHECK6-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[TMP23]], i64 [[IDXPROM]]
// CHECK6-NEXT:    [[TMP25:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP26:%.*]] = load ptr, ptr [[TMP3]], align 8, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP27:%.*]] = load i8, ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    [[IDXPROM31:%.*]] = sext i8 [[TMP27]] to i64
// CHECK6-NEXT:    [[ARRAYIDX32:%.*]] = getelementptr inbounds float, ptr [[TMP26]], i64 [[IDXPROM31]]
// CHECK6-NEXT:    [[TMP28:%.*]] = load float, ptr [[ARRAYIDX32]], align 4, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL33:%.*]] = fmul float [[TMP25]], [[TMP28]]
// CHECK6-NEXT:    [[TMP29:%.*]] = load ptr, ptr [[TMP4]], align 8, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP30:%.*]] = load i8, ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    [[IDXPROM34:%.*]] = sext i8 [[TMP30]] to i64
// CHECK6-NEXT:    [[ARRAYIDX35:%.*]] = getelementptr inbounds float, ptr [[TMP29]], i64 [[IDXPROM34]]
// CHECK6-NEXT:    [[TMP31:%.*]] = load float, ptr [[ARRAYIDX35]], align 4, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL36:%.*]] = fmul float [[MUL33]], [[TMP31]]
// CHECK6-NEXT:    [[TMP32:%.*]] = load ptr, ptr [[TMP1]], align 8, !llvm.access.group [[ACC_GRP14]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP33:%.*]] = load i8, ptr [[I15]], align 1, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    [[IDXPROM37:%.*]] = sext i8 [[TMP33]] to i64
// CHECK6-NEXT:    [[ARRAYIDX38:%.*]] = getelementptr inbounds float, ptr [[TMP32]], i64 [[IDXPROM37]]
// CHECK6-NEXT:    store float [[MUL36]], ptr [[ARRAYIDX38]], align 4, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK6:       omp.body.continue:
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK6:       omp.inner.for.inc:
// CHECK6-NEXT:    [[TMP34:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    [[ADD39:%.*]] = add nsw i64 [[TMP34]], 1
// CHECK6-NEXT:    store i64 [[ADD39]], ptr [[DOTOMP_IV]], align 8, !llvm.access.group [[ACC_GRP14]]
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND]], !llvm.loop [[LOOP15:![0-9]+]]
// CHECK6:       omp.inner.for.end:
// CHECK6-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK6:       omp.dispatch.inc:
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK6:       omp.dispatch.end:
// CHECK6-NEXT:    [[TMP35:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    [[TMP36:%.*]] = load i32, ptr [[TMP35]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB2]], i32 [[TMP36]])
// CHECK6-NEXT:    br label [[OMP_PRECOND_END]]
// CHECK6:       omp.precond.end:
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z7runtimePfS_S_S_
// CHECK6-SAME: (ptr noundef [[A:%.*]], ptr noundef [[B:%.*]], ptr noundef [[C:%.*]], ptr noundef [[D:%.*]]) #[[ATTR0]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON]], ptr [[X]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[X]], align 4
// CHECK6-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 4, ptr @_Z7runtimePfS_S_S_.omp_outlined, ptr [[A_ADDR]], ptr [[B_ADDR]], ptr [[C_ADDR]], ptr [[D_ADDR]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z7runtimePfS_S_S_.omp_outlined
// CHECK6-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[B:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[C:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[D:%.*]]) #[[ATTR1]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[B_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[C_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[D_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[TMP:%.*]] = alloca i8, align 1
// CHECK6-NEXT:    [[_TMP1:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[I:%.*]] = alloca i8, align 1
// CHECK6-NEXT:    [[X:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[B]], ptr [[B_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[C]], ptr [[C_ADDR]], align 8
// CHECK6-NEXT:    store ptr [[D]], ptr [[D_ADDR]], align 8
// CHECK6-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[B_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[C_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[D_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    store i32 199, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON6:%.*]] = freeze i8 poison
// CHECK6-NEXT:    store i8 [[FREEZE_POISON6]], ptr [[I]], align 1
// CHECK6-NEXT:    [[FREEZE_POISON7:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON7]], ptr [[X]], align 4
// CHECK6-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    [[TMP5:%.*]] = load i32, ptr [[TMP4]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void @__kmpc_dispatch_init_4(ptr @[[GLOB2]], i32 [[TMP5]], i32 1073741861, i32 0, i32 199, i32 1, i32 1)
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK6:       omp.dispatch.cond:
// CHECK6-NEXT:    [[TMP6:%.*]] = call i32 @__kmpc_dispatch_next_4(ptr @[[GLOB2]], i32 [[TMP5]], ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]])
// CHECK6-NEXT:    [[TOBOOL:%.*]] = icmp ne i32 [[TMP6]], 0
// CHECK6-NEXT:    br i1 [[TOBOOL]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_END:%.*]]
// CHECK6:       omp.dispatch.body:
// CHECK6-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    store i32 [[TMP7]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK6:       omp.inner.for.cond:
// CHECK6-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17:![0-9]+]]
// CHECK6-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK6-NEXT:    [[CMP:%.*]] = icmp sle i32 [[TMP8]], [[TMP9]]
// CHECK6-NEXT:    br i1 [[CMP]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK6:       omp.inner.for.body:
// CHECK6-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK6-NEXT:    [[DIV:%.*]] = sdiv i32 [[TMP10]], 20
// CHECK6-NEXT:    [[MUL:%.*]] = mul nsw i32 [[DIV]], 1
// CHECK6-NEXT:    [[ADD:%.*]] = add nsw i32 48, [[MUL]]
// CHECK6-NEXT:    [[CONV:%.*]] = trunc i32 [[ADD]] to i8
// CHECK6-NEXT:    store i8 [[CONV]], ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK6-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK6-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK6-NEXT:    [[DIV8:%.*]] = sdiv i32 [[TMP12]], 20
// CHECK6-NEXT:    [[MUL9:%.*]] = mul nsw i32 [[DIV8]], 20
// CHECK6-NEXT:    [[SUB:%.*]] = sub nsw i32 [[TMP11]], [[MUL9]]
// CHECK6-NEXT:    [[MUL10:%.*]] = mul nsw i32 [[SUB]], 1
// CHECK6-NEXT:    [[ADD11:%.*]] = add nsw i32 -10, [[MUL10]]
// CHECK6-NEXT:    store i32 [[ADD11]], ptr [[X]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK6-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[TMP1]], align 8, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP14:%.*]] = load i8, ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK6-NEXT:    [[IDXPROM:%.*]] = zext i8 [[TMP14]] to i64
// CHECK6-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[TMP13]], i64 [[IDXPROM]]
// CHECK6-NEXT:    [[TMP15:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[TMP2]], align 8, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP17:%.*]] = load i8, ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK6-NEXT:    [[IDXPROM12:%.*]] = zext i8 [[TMP17]] to i64
// CHECK6-NEXT:    [[ARRAYIDX13:%.*]] = getelementptr inbounds nuw float, ptr [[TMP16]], i64 [[IDXPROM12]]
// CHECK6-NEXT:    [[TMP18:%.*]] = load float, ptr [[ARRAYIDX13]], align 4, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL14:%.*]] = fmul float [[TMP15]], [[TMP18]]
// CHECK6-NEXT:    [[TMP19:%.*]] = load ptr, ptr [[TMP3]], align 8, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP20:%.*]] = load i8, ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK6-NEXT:    [[IDXPROM15:%.*]] = zext i8 [[TMP20]] to i64
// CHECK6-NEXT:    [[ARRAYIDX16:%.*]] = getelementptr inbounds nuw float, ptr [[TMP19]], i64 [[IDXPROM15]]
// CHECK6-NEXT:    [[TMP21:%.*]] = load float, ptr [[ARRAYIDX16]], align 4, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[MUL17:%.*]] = fmul float [[MUL14]], [[TMP21]]
// CHECK6-NEXT:    [[TMP22:%.*]] = load ptr, ptr [[TMP0]], align 8, !llvm.access.group [[ACC_GRP17]], !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP23:%.*]] = load i8, ptr [[I]], align 1, !llvm.access.group [[ACC_GRP17]]
// CHECK6-NEXT:    [[IDXPROM18:%.*]] = zext i8 [[TMP23]] to i64
// CHECK6-NEXT:    [[ARRAYIDX19:%.*]] = getelementptr inbounds nuw float, ptr [[TMP22]], i64 [[IDXPROM18]]
// CHECK6-NEXT:    store float [[MUL17]], ptr [[ARRAYIDX19]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK6-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK6:       omp.body.continue:
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK6:       omp.inner.for.inc:
// CHECK6-NEXT:    [[TMP24:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK6-NEXT:    [[ADD20:%.*]] = add nsw i32 [[TMP24]], 1
// CHECK6-NEXT:    store i32 [[ADD20]], ptr [[DOTOMP_IV]], align 4, !llvm.access.group [[ACC_GRP17]]
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND]], !llvm.loop [[LOOP18:![0-9]+]]
// CHECK6:       omp.inner.for.end:
// CHECK6-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK6:       omp.dispatch.inc:
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK6:       omp.dispatch.end:
// CHECK6-NEXT:    call void @__kmpc_dispatch_deinit(ptr @[[GLOB2]], i32 [[TMP5]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z3foov
// CHECK6-SAME: () #[[ATTR0]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    call void @_Z8mayThrowv()
// CHECK6-NEXT:    ret i32 0
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z12parallel_forPfi
// CHECK6-SAME: (ptr noundef [[A:%.*]], i32 noundef [[N:%.*]]) #[[ATTR0]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[N_ADDR:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[SAVED_STACK:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[N_CASTED:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store i32 [[N]], ptr [[N_ADDR]], align 4
// CHECK6-NEXT:    [[TMP0:%.*]] = load i32, ptr [[N_ADDR]], align 4
// CHECK6-NEXT:    [[TMP1:%.*]] = zext i32 [[TMP0]] to i64
// CHECK6-NEXT:    [[TMP2:%.*]] = call ptr @llvm.stacksave.p0()
// CHECK6-NEXT:    store ptr [[TMP2]], ptr [[SAVED_STACK]], align 8
// CHECK6-NEXT:    [[VLA:%.*]] = alloca float, i64 [[TMP1]], align 16
// CHECK6-NEXT:    store i64 [[TMP1]], ptr [[__VLA_EXPR0]], align 8
// CHECK6-NEXT:    [[TMP3:%.*]] = load i32, ptr [[N_ADDR]], align 4
// CHECK6-NEXT:    store i32 [[TMP3]], ptr [[N_CASTED]], align 4
// CHECK6-NEXT:    [[TMP4:%.*]] = load i64, ptr [[N_CASTED]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 3, ptr @_Z12parallel_forPfi.omp_outlined, ptr [[A_ADDR]], i64 [[TMP1]], i64 [[TMP4]])
// CHECK6-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[SAVED_STACK]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void @llvm.stackrestore.p0(ptr [[TMP5]])
// CHECK6-NEXT:    ret void
//
//
// CHECK6-LABEL: define {{[^@]+}}@_Z12parallel_forPfi.omp_outlined
// CHECK6-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 8 dereferenceable(8) [[A:%.*]], i64 noundef [[VLA:%.*]], i64 noundef [[N:%.*]]) #[[ATTR1]] {
// CHECK6-NEXT:  entry:
// CHECK6-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[A_ADDR:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[VLA_ADDR:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[N_ADDR:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    [[SAVED_STACK:%.*]] = alloca ptr, align 8
// CHECK6-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i64, align 8
// CHECK6-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK6-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK6-NEXT:    store ptr [[A]], ptr [[A_ADDR]], align 8
// CHECK6-NEXT:    store i64 [[VLA]], ptr [[VLA_ADDR]], align 8
// CHECK6-NEXT:    store i64 [[N]], ptr [[N_ADDR]], align 8
// CHECK6-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[A_ADDR]], align 8, !nonnull [[META3]], !align [[META6]]
// CHECK6-NEXT:    [[TMP1:%.*]] = load i64, ptr [[VLA_ADDR]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    store i32 16908288, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK6-NEXT:    [[TMP2:%.*]] = call ptr @llvm.stacksave.p0()
// CHECK6-NEXT:    store ptr [[TMP2]], ptr [[SAVED_STACK]], align 8
// CHECK6-NEXT:    [[VLA5:%.*]] = alloca float, i64 [[TMP1]], align 16
// CHECK6-NEXT:    store i64 [[TMP1]], ptr [[__VLA_EXPR0]], align 8
// CHECK6-NEXT:    [[FREEZE_POISON6:%.*]] = freeze i32 poison
// CHECK6-NEXT:    store i32 [[FREEZE_POISON6]], ptr [[I]], align 4
// CHECK6-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK6-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP3]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void @__kmpc_for_static_init_4u(ptr @[[GLOB1]], i32 [[TMP4]], i32 33, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 5)
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND:%.*]]
// CHECK6:       omp.dispatch.cond:
// CHECK6-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[TMP5]], 16908288
// CHECK6-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK6:       cond.true:
// CHECK6-NEXT:    br label [[COND_END:%.*]]
// CHECK6:       cond.false:
// CHECK6-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    br label [[COND_END]]
// CHECK6:       cond.end:
// CHECK6-NEXT:    [[COND:%.*]] = phi i32 [ 16908288, [[COND_TRUE]] ], [ [[TMP6]], [[COND_FALSE]] ]
// CHECK6-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    store i32 [[TMP7]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[TMP8:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[TMP9:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[CMP7:%.*]] = icmp ule i32 [[TMP8]], [[TMP9]]
// CHECK6-NEXT:    br i1 [[CMP7]], label [[OMP_DISPATCH_BODY:%.*]], label [[OMP_DISPATCH_CLEANUP:%.*]]
// CHECK6:       omp.dispatch.cleanup:
// CHECK6-NEXT:    br label [[OMP_DISPATCH_END:%.*]]
// CHECK6:       omp.dispatch.body:
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK6:       omp.inner.for.cond:
// CHECK6-NEXT:    [[TMP10:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[TMP11:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[CMP8:%.*]] = icmp ule i32 [[TMP10]], [[TMP11]]
// CHECK6-NEXT:    br i1 [[CMP8]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_COND_CLEANUP:%.*]]
// CHECK6:       omp.inner.for.cond.cleanup:
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_END:%.*]]
// CHECK6:       omp.inner.for.body:
// CHECK6-NEXT:    [[TMP12:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[MUL:%.*]] = mul i32 [[TMP12]], 127
// CHECK6-NEXT:    [[ADD:%.*]] = add i32 131071, [[MUL]]
// CHECK6-NEXT:    store i32 [[ADD]], ptr [[I]], align 4
// CHECK6-NEXT:    [[CALL:%.*]] = call noundef i32 @_Z3foov()
// CHECK6-NEXT:    [[CONV:%.*]] = sitofp i32 [[CALL]] to float
// CHECK6-NEXT:    [[TMP13:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM:%.*]] = zext i32 [[TMP13]] to i64
// CHECK6-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw float, ptr [[VLA5]], i64 [[IDXPROM]]
// CHECK6-NEXT:    [[TMP14:%.*]] = load float, ptr [[ARRAYIDX]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[ADD9:%.*]] = fadd float [[CONV]], [[TMP14]]
// CHECK6-NEXT:    [[TMP15:%.*]] = load i32, ptr [[N_ADDR]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[CONV10:%.*]] = sitofp i32 [[TMP15]] to float
// CHECK6-NEXT:    [[ADD11:%.*]] = fadd float [[ADD9]], [[CONV10]]
// CHECK6-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[TMP0]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[TMP17:%.*]] = load i32, ptr [[I]], align 4
// CHECK6-NEXT:    [[IDXPROM12:%.*]] = zext i32 [[TMP17]] to i64
// CHECK6-NEXT:    [[ARRAYIDX13:%.*]] = getelementptr inbounds nuw float, ptr [[TMP16]], i64 [[IDXPROM12]]
// CHECK6-NEXT:    [[TMP18:%.*]] = load float, ptr [[ARRAYIDX13]], align 4, !freeze_bits [[META3]]
// CHECK6-NEXT:    [[ADD14:%.*]] = fadd float [[TMP18]], [[ADD11]]
// CHECK6-NEXT:    store float [[ADD14]], ptr [[ARRAYIDX13]], align 4
// CHECK6-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK6:       omp.body.continue:
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK6:       omp.inner.for.inc:
// CHECK6-NEXT:    [[TMP19:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    [[ADD15:%.*]] = add i32 [[TMP19]], 1
// CHECK6-NEXT:    store i32 [[ADD15]], ptr [[DOTOMP_IV]], align 4
// CHECK6-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK6:       omp.inner.for.end:
// CHECK6-NEXT:    br label [[OMP_DISPATCH_INC:%.*]]
// CHECK6:       omp.dispatch.inc:
// CHECK6-NEXT:    [[TMP20:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    [[TMP21:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    [[ADD16:%.*]] = add i32 [[TMP20]], [[TMP21]]
// CHECK6-NEXT:    store i32 [[ADD16]], ptr [[DOTOMP_LB]], align 4
// CHECK6-NEXT:    [[TMP22:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    [[TMP23:%.*]] = load i32, ptr [[DOTOMP_STRIDE]], align 4
// CHECK6-NEXT:    [[ADD17:%.*]] = add i32 [[TMP22]], [[TMP23]]
// CHECK6-NEXT:    store i32 [[ADD17]], ptr [[DOTOMP_UB]], align 4
// CHECK6-NEXT:    br label [[OMP_DISPATCH_COND]]
// CHECK6:       omp.dispatch.end:
// CHECK6-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP4]])
// CHECK6-NEXT:    [[TMP24:%.*]] = load ptr, ptr [[SAVED_STACK]], align 8, !freeze_bits [[META3]]
// CHECK6-NEXT:    call void @llvm.stackrestore.p0(ptr [[TMP24]])
// CHECK6-NEXT:    ret void
//
//
// CHECK11-LABEL: define {{[^@]+}}@_Z9incrementv
// CHECK11-SAME: () #[[ATTR0:[0-9]+]] {
// CHECK11-NEXT:  entry:
// CHECK11-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[I:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[TMP0:%.*]] = call i32 @__kmpc_global_thread_num(ptr @[[GLOB2:[0-9]+]])
// CHECK11-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK11-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK11-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK11-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK11-NEXT:    store i32 4, ptr [[DOTOMP_UB]], align 4
// CHECK11-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK11-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK11-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK11-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK11-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[I]], align 4
// CHECK11-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB1:[0-9]+]], i32 [[TMP0]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1)
// CHECK11-NEXT:    [[TMP1:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK11-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], 4
// CHECK11-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK11:       cond.true:
// CHECK11-NEXT:    br label [[COND_END:%.*]]
// CHECK11:       cond.false:
// CHECK11-NEXT:    [[TMP2:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK11-NEXT:    br label [[COND_END]]
// CHECK11:       cond.end:
// CHECK11-NEXT:    [[COND:%.*]] = phi i32 [ 4, [[COND_TRUE]] ], [ [[TMP2]], [[COND_FALSE]] ]
// CHECK11-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK11-NEXT:    [[TMP3:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK11-NEXT:    store i32 [[TMP3]], ptr [[DOTOMP_IV]], align 4
// CHECK11-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK11:       omp.inner.for.cond:
// CHECK11-NEXT:    [[TMP4:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK11-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK11-NEXT:    [[CMP6:%.*]] = icmp sle i32 [[TMP4]], [[TMP5]]
// CHECK11-NEXT:    br i1 [[CMP6]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK11:       omp.inner.for.body:
// CHECK11-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK11-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP6]], 1
// CHECK11-NEXT:    [[ADD:%.*]] = add nsw i32 0, [[MUL]]
// CHECK11-NEXT:    store i32 [[ADD]], ptr [[I]], align 4
// CHECK11-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK11:       omp.body.continue:
// CHECK11-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK11:       omp.inner.for.inc:
// CHECK11-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK11-NEXT:    [[ADD7:%.*]] = add nsw i32 [[TMP7]], 1
// CHECK11-NEXT:    store i32 [[ADD7]], ptr [[DOTOMP_IV]], align 4
// CHECK11-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK11:       omp.inner.for.end:
// CHECK11-NEXT:    br label [[OMP_LOOP_EXIT:%.*]]
// CHECK11:       omp.loop.exit:
// CHECK11-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP0]])
// CHECK11-NEXT:    call void @__kmpc_barrier(ptr @[[GLOB3:[0-9]+]], i32 [[TMP0]])
// CHECK11-NEXT:    ret i32 0
//
//
// CHECK11-LABEL: define {{[^@]+}}@_Z16decrement_nowaitv
// CHECK11-SAME: () #[[ATTR0]] {
// CHECK11-NEXT:  entry:
// CHECK11-NEXT:    [[DOTOMP_IV:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[TMP:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[DOTOMP_LB:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[DOTOMP_UB:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[J:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[TMP0:%.*]] = call i32 @__kmpc_global_thread_num(ptr @[[GLOB2]])
// CHECK11-NEXT:    [[FREEZE_POISON:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 4
// CHECK11-NEXT:    [[FREEZE_POISON1:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON1]], ptr [[DOTOMP_LB]], align 4
// CHECK11-NEXT:    store i32 0, ptr [[DOTOMP_LB]], align 4
// CHECK11-NEXT:    [[FREEZE_POISON2:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON2]], ptr [[DOTOMP_UB]], align 4
// CHECK11-NEXT:    store i32 4, ptr [[DOTOMP_UB]], align 4
// CHECK11-NEXT:    [[FREEZE_POISON3:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON3]], ptr [[DOTOMP_STRIDE]], align 4
// CHECK11-NEXT:    store i32 1, ptr [[DOTOMP_STRIDE]], align 4
// CHECK11-NEXT:    [[FREEZE_POISON4:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON4]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK11-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK11-NEXT:    [[FREEZE_POISON5:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON5]], ptr [[J]], align 4
// CHECK11-NEXT:    call void @__kmpc_for_static_init_4(ptr @[[GLOB1]], i32 [[TMP0]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i32 1, i32 1)
// CHECK11-NEXT:    [[TMP1:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK11-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[TMP1]], 4
// CHECK11-NEXT:    br i1 [[CMP]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK11:       cond.true:
// CHECK11-NEXT:    br label [[COND_END:%.*]]
// CHECK11:       cond.false:
// CHECK11-NEXT:    [[TMP2:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK11-NEXT:    br label [[COND_END]]
// CHECK11:       cond.end:
// CHECK11-NEXT:    [[COND:%.*]] = phi i32 [ 4, [[COND_TRUE]] ], [ [[TMP2]], [[COND_FALSE]] ]
// CHECK11-NEXT:    store i32 [[COND]], ptr [[DOTOMP_UB]], align 4
// CHECK11-NEXT:    [[TMP3:%.*]] = load i32, ptr [[DOTOMP_LB]], align 4
// CHECK11-NEXT:    store i32 [[TMP3]], ptr [[DOTOMP_IV]], align 4
// CHECK11-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK11:       omp.inner.for.cond:
// CHECK11-NEXT:    [[TMP4:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK11-NEXT:    [[TMP5:%.*]] = load i32, ptr [[DOTOMP_UB]], align 4
// CHECK11-NEXT:    [[CMP6:%.*]] = icmp sle i32 [[TMP4]], [[TMP5]]
// CHECK11-NEXT:    br i1 [[CMP6]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK11:       omp.inner.for.body:
// CHECK11-NEXT:    [[TMP6:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK11-NEXT:    [[MUL:%.*]] = mul nsw i32 [[TMP6]], 1
// CHECK11-NEXT:    [[SUB:%.*]] = sub nsw i32 5, [[MUL]]
// CHECK11-NEXT:    store i32 [[SUB]], ptr [[J]], align 4
// CHECK11-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK11:       omp.body.continue:
// CHECK11-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK11:       omp.inner.for.inc:
// CHECK11-NEXT:    [[TMP7:%.*]] = load i32, ptr [[DOTOMP_IV]], align 4
// CHECK11-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP7]], 1
// CHECK11-NEXT:    store i32 [[ADD]], ptr [[DOTOMP_IV]], align 4
// CHECK11-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK11:       omp.inner.for.end:
// CHECK11-NEXT:    br label [[OMP_LOOP_EXIT:%.*]]
// CHECK11:       omp.loop.exit:
// CHECK11-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP0]])
// CHECK11-NEXT:    ret i32 0
//
//
// CHECK11-LABEL: define {{[^@]+}}@_Z16range_for_singlev
// CHECK11-SAME: () #[[ATTR0]] {
// CHECK11-NEXT:  entry:
// CHECK11-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 16
// CHECK11-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[ARR]], i8 0, i64 40, i1 false)
// CHECK11-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 1, ptr @_Z16range_for_singlev.omp_outlined, ptr [[ARR]])
// CHECK11-NEXT:    ret void
//
//
// CHECK11-LABEL: define {{[^@]+}}@_Z16range_for_singlev.omp_outlined
// CHECK11-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 4 dereferenceable(40) [[ARR:%.*]]) #[[ATTR4:[0-9]+]] {
// CHECK11-NEXT:  entry:
// CHECK11-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[ARR_ADDR:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK11-NEXT:    [[TMP:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[__RANGE1:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[__END1:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTCAPTURE_EXPR_:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTCAPTURE_EXPR_5:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTCAPTURE_EXPR_7:%.*]] = alloca i64, align 8
// CHECK11-NEXT:    [[__BEGIN1:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK11-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK11-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK11-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[__BEGIN115:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[A:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK11-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK11-NEXT:    store ptr [[ARR]], ptr [[ARR_ADDR]], align 8
// CHECK11-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[ARR_ADDR]], align 8, !nonnull [[META3:![0-9]+]], !align [[META4:![0-9]+]]
// CHECK11-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK11-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON1:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON1]], ptr [[__RANGE1]], align 8
// CHECK11-NEXT:    store ptr [[TMP0]], ptr [[__RANGE1]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON2:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON2]], ptr [[__END1]], align 8
// CHECK11-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[__RANGE1]], align 8, !nonnull [[META3]], !align [[META4]]
// CHECK11-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [10 x i32], ptr [[TMP1]], i64 0, i64 0
// CHECK11-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[ARRAYDECAY]], i64 10
// CHECK11-NEXT:    store ptr [[ADD_PTR]], ptr [[__END1]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON3:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON3]], ptr [[DOTCAPTURE_EXPR_]], align 8
// CHECK11-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[__RANGE1]], align 8, !nonnull [[META3]], !align [[META4]]
// CHECK11-NEXT:    [[ARRAYDECAY4:%.*]] = getelementptr inbounds [10 x i32], ptr [[TMP2]], i64 0, i64 0
// CHECK11-NEXT:    store ptr [[ARRAYDECAY4]], ptr [[DOTCAPTURE_EXPR_]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON6:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON6]], ptr [[DOTCAPTURE_EXPR_5]], align 8
// CHECK11-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[__END1]], align 8
// CHECK11-NEXT:    store ptr [[TMP3]], ptr [[DOTCAPTURE_EXPR_5]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON8:%.*]] = freeze i64 poison
// CHECK11-NEXT:    store i64 [[FREEZE_POISON8]], ptr [[DOTCAPTURE_EXPR_7]], align 8
// CHECK11-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_5]], align 8
// CHECK11-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_]], align 8
// CHECK11-NEXT:    [[SUB_PTR_LHS_CAST:%.*]] = ptrtoint ptr [[TMP4]] to i64
// CHECK11-NEXT:    [[SUB_PTR_RHS_CAST:%.*]] = ptrtoint ptr [[TMP5]] to i64
// CHECK11-NEXT:    [[SUB_PTR_SUB:%.*]] = sub i64 [[SUB_PTR_LHS_CAST]], [[SUB_PTR_RHS_CAST]]
// CHECK11-NEXT:    [[SUB_PTR_DIV:%.*]] = sdiv exact i64 [[SUB_PTR_SUB]], 4
// CHECK11-NEXT:    [[SUB:%.*]] = sub nsw i64 [[SUB_PTR_DIV]], 1
// CHECK11-NEXT:    [[ADD:%.*]] = add nsw i64 [[SUB]], 1
// CHECK11-NEXT:    [[DIV:%.*]] = sdiv i64 [[ADD]], 1
// CHECK11-NEXT:    [[SUB9:%.*]] = sub nsw i64 [[DIV]], 1
// CHECK11-NEXT:    store i64 [[SUB9]], ptr [[DOTCAPTURE_EXPR_7]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON10:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON10]], ptr [[__BEGIN1]], align 8
// CHECK11-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_]], align 8
// CHECK11-NEXT:    store ptr [[TMP6]], ptr [[__BEGIN1]], align 8
// CHECK11-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_]], align 8
// CHECK11-NEXT:    [[TMP8:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_5]], align 8
// CHECK11-NEXT:    [[CMP:%.*]] = icmp ult ptr [[TMP7]], [[TMP8]]
// CHECK11-NEXT:    br i1 [[CMP]], label [[OMP_PRECOND_THEN:%.*]], label [[OMP_PRECOND_END:%.*]]
// CHECK11:       omp.precond.then:
// CHECK11-NEXT:    [[FREEZE_POISON11:%.*]] = freeze i64 poison
// CHECK11-NEXT:    store i64 [[FREEZE_POISON11]], ptr [[DOTOMP_LB]], align 8
// CHECK11-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON12:%.*]] = freeze i64 poison
// CHECK11-NEXT:    store i64 [[FREEZE_POISON12]], ptr [[DOTOMP_UB]], align 8
// CHECK11-NEXT:    [[TMP9:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_7]], align 8
// CHECK11-NEXT:    store i64 [[TMP9]], ptr [[DOTOMP_UB]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON13:%.*]] = freeze i64 poison
// CHECK11-NEXT:    store i64 [[FREEZE_POISON13]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK11-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON14:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON14]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK11-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK11-NEXT:    [[FREEZE_POISON16:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON16]], ptr [[__BEGIN115]], align 8
// CHECK11-NEXT:    [[TMP10:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK11-NEXT:    [[TMP11:%.*]] = load i32, ptr [[TMP10]], align 4, !freeze_bits [[META3]]
// CHECK11-NEXT:    call void @__kmpc_for_static_init_8(ptr @[[GLOB1]], i32 [[TMP11]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i64 1, i64 1)
// CHECK11-NEXT:    [[TMP12:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK11-NEXT:    [[TMP13:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_7]], align 8
// CHECK11-NEXT:    [[CMP17:%.*]] = icmp sgt i64 [[TMP12]], [[TMP13]]
// CHECK11-NEXT:    br i1 [[CMP17]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK11:       cond.true:
// CHECK11-NEXT:    [[TMP14:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_7]], align 8
// CHECK11-NEXT:    br label [[COND_END:%.*]]
// CHECK11:       cond.false:
// CHECK11-NEXT:    [[TMP15:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK11-NEXT:    br label [[COND_END]]
// CHECK11:       cond.end:
// CHECK11-NEXT:    [[COND:%.*]] = phi i64 [ [[TMP14]], [[COND_TRUE]] ], [ [[TMP15]], [[COND_FALSE]] ]
// CHECK11-NEXT:    store i64 [[COND]], ptr [[DOTOMP_UB]], align 8
// CHECK11-NEXT:    [[TMP16:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK11-NEXT:    store i64 [[TMP16]], ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK11:       omp.inner.for.cond:
// CHECK11-NEXT:    [[TMP17:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    [[TMP18:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK11-NEXT:    [[CMP18:%.*]] = icmp sle i64 [[TMP17]], [[TMP18]]
// CHECK11-NEXT:    br i1 [[CMP18]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK11:       omp.inner.for.body:
// CHECK11-NEXT:    [[TMP19:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_]], align 8
// CHECK11-NEXT:    [[TMP20:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    [[MUL:%.*]] = mul nsw i64 [[TMP20]], 1
// CHECK11-NEXT:    [[ADD_PTR19:%.*]] = getelementptr inbounds i32, ptr [[TMP19]], i64 [[MUL]]
// CHECK11-NEXT:    store ptr [[ADD_PTR19]], ptr [[__BEGIN115]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON20:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON20]], ptr [[A]], align 8
// CHECK11-NEXT:    [[TMP21:%.*]] = load ptr, ptr [[__BEGIN115]], align 8
// CHECK11-NEXT:    store ptr [[TMP21]], ptr [[A]], align 8
// CHECK11-NEXT:    [[TMP22:%.*]] = load ptr, ptr [[A]], align 8, !nonnull [[META3]], !align [[META4]]
// CHECK11-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK11:       omp.body.continue:
// CHECK11-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK11:       omp.inner.for.inc:
// CHECK11-NEXT:    [[TMP23:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    [[ADD21:%.*]] = add nsw i64 [[TMP23]], 1
// CHECK11-NEXT:    store i64 [[ADD21]], ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK11:       omp.inner.for.end:
// CHECK11-NEXT:    br label [[OMP_LOOP_EXIT:%.*]]
// CHECK11:       omp.loop.exit:
// CHECK11-NEXT:    [[TMP24:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK11-NEXT:    [[TMP25:%.*]] = load i32, ptr [[TMP24]], align 4, !freeze_bits [[META3]]
// CHECK11-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP25]])
// CHECK11-NEXT:    br label [[OMP_PRECOND_END]]
// CHECK11:       omp.precond.end:
// CHECK11-NEXT:    ret void
//
//
// CHECK11-LABEL: define {{[^@]+}}@_Z19range_for_collapsedv
// CHECK11-SAME: () #[[ATTR0]] {
// CHECK11-NEXT:  entry:
// CHECK11-NEXT:    [[ARR:%.*]] = alloca [10 x i32], align 16
// CHECK11-NEXT:    call void @llvm.memset.p0.i64(ptr align 16 [[ARR]], i8 0, i64 40, i1 false)
// CHECK11-NEXT:    call void (ptr, i32, ptr, ...) @__kmpc_fork_call(ptr @[[GLOB2]], i32 1, ptr @_Z19range_for_collapsedv.omp_outlined, ptr [[ARR]])
// CHECK11-NEXT:    ret void
//
//
// CHECK11-LABEL: define {{[^@]+}}@_Z19range_for_collapsedv.omp_outlined
// CHECK11-SAME: (ptr noalias noundef [[DOTGLOBAL_TID_:%.*]], ptr noalias noundef [[DOTBOUND_TID_:%.*]], ptr noundef nonnull align 4 dereferenceable(40) [[ARR:%.*]]) #[[ATTR4]] {
// CHECK11-NEXT:  entry:
// CHECK11-NEXT:    [[DOTGLOBAL_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTBOUND_TID__ADDR:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[ARR_ADDR:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTOMP_IV:%.*]] = alloca i64, align 8
// CHECK11-NEXT:    [[TMP:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[_TMP1:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[__RANGE1:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[__END1:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[__RANGE2:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[__END2:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTCAPTURE_EXPR_:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTCAPTURE_EXPR_10:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTCAPTURE_EXPR_12:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTCAPTURE_EXPR_15:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTCAPTURE_EXPR_17:%.*]] = alloca i64, align 8
// CHECK11-NEXT:    [[__BEGIN1:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[__BEGIN2:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[DOTOMP_LB:%.*]] = alloca i64, align 8
// CHECK11-NEXT:    [[DOTOMP_UB:%.*]] = alloca i64, align 8
// CHECK11-NEXT:    [[DOTOMP_STRIDE:%.*]] = alloca i64, align 8
// CHECK11-NEXT:    [[DOTOMP_IS_LAST:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    [[__BEGIN134:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[__BEGIN236:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[A:%.*]] = alloca ptr, align 8
// CHECK11-NEXT:    [[B:%.*]] = alloca i32, align 4
// CHECK11-NEXT:    store ptr [[DOTGLOBAL_TID_]], ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK11-NEXT:    store ptr [[DOTBOUND_TID_]], ptr [[DOTBOUND_TID__ADDR]], align 8
// CHECK11-NEXT:    store ptr [[ARR]], ptr [[ARR_ADDR]], align 8
// CHECK11-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[ARR_ADDR]], align 8, !nonnull [[META3]], !align [[META4]]
// CHECK11-NEXT:    [[FREEZE_POISON:%.*]] = freeze i64 poison
// CHECK11-NEXT:    store i64 [[FREEZE_POISON]], ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON2:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON2]], ptr [[__RANGE1]], align 8
// CHECK11-NEXT:    store ptr [[TMP0]], ptr [[__RANGE1]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON3:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON3]], ptr [[__END1]], align 8
// CHECK11-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[__RANGE1]], align 8, !nonnull [[META3]], !align [[META4]]
// CHECK11-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [10 x i32], ptr [[TMP1]], i64 0, i64 0
// CHECK11-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[ARRAYDECAY]], i64 10
// CHECK11-NEXT:    store ptr [[ADD_PTR]], ptr [[__END1]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON4:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON4]], ptr [[__RANGE2]], align 8
// CHECK11-NEXT:    store ptr [[TMP0]], ptr [[__RANGE2]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON5:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON5]], ptr [[__END2]], align 8
// CHECK11-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[__RANGE2]], align 8, !nonnull [[META3]], !align [[META4]]
// CHECK11-NEXT:    [[ARRAYDECAY6:%.*]] = getelementptr inbounds [10 x i32], ptr [[TMP2]], i64 0, i64 0
// CHECK11-NEXT:    [[ADD_PTR7:%.*]] = getelementptr inbounds i32, ptr [[ARRAYDECAY6]], i64 10
// CHECK11-NEXT:    store ptr [[ADD_PTR7]], ptr [[__END2]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON8:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON8]], ptr [[DOTCAPTURE_EXPR_]], align 8
// CHECK11-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[__RANGE1]], align 8, !nonnull [[META3]], !align [[META4]]
// CHECK11-NEXT:    [[ARRAYDECAY9:%.*]] = getelementptr inbounds [10 x i32], ptr [[TMP3]], i64 0, i64 0
// CHECK11-NEXT:    store ptr [[ARRAYDECAY9]], ptr [[DOTCAPTURE_EXPR_]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON11:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON11]], ptr [[DOTCAPTURE_EXPR_10]], align 8
// CHECK11-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[__END1]], align 8
// CHECK11-NEXT:    store ptr [[TMP4]], ptr [[DOTCAPTURE_EXPR_10]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON13:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON13]], ptr [[DOTCAPTURE_EXPR_12]], align 8
// CHECK11-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[__RANGE2]], align 8, !nonnull [[META3]], !align [[META4]]
// CHECK11-NEXT:    [[ARRAYDECAY14:%.*]] = getelementptr inbounds [10 x i32], ptr [[TMP5]], i64 0, i64 0
// CHECK11-NEXT:    store ptr [[ARRAYDECAY14]], ptr [[DOTCAPTURE_EXPR_12]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON16:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON16]], ptr [[DOTCAPTURE_EXPR_15]], align 8
// CHECK11-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[__END2]], align 8
// CHECK11-NEXT:    store ptr [[TMP6]], ptr [[DOTCAPTURE_EXPR_15]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON18:%.*]] = freeze i64 poison
// CHECK11-NEXT:    store i64 [[FREEZE_POISON18]], ptr [[DOTCAPTURE_EXPR_17]], align 8
// CHECK11-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_10]], align 8
// CHECK11-NEXT:    [[TMP8:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_]], align 8
// CHECK11-NEXT:    [[SUB_PTR_LHS_CAST:%.*]] = ptrtoint ptr [[TMP7]] to i64
// CHECK11-NEXT:    [[SUB_PTR_RHS_CAST:%.*]] = ptrtoint ptr [[TMP8]] to i64
// CHECK11-NEXT:    [[SUB_PTR_SUB:%.*]] = sub i64 [[SUB_PTR_LHS_CAST]], [[SUB_PTR_RHS_CAST]]
// CHECK11-NEXT:    [[SUB_PTR_DIV:%.*]] = sdiv exact i64 [[SUB_PTR_SUB]], 4
// CHECK11-NEXT:    [[SUB:%.*]] = sub nsw i64 [[SUB_PTR_DIV]], 1
// CHECK11-NEXT:    [[ADD:%.*]] = add nsw i64 [[SUB]], 1
// CHECK11-NEXT:    [[DIV:%.*]] = sdiv i64 [[ADD]], 1
// CHECK11-NEXT:    [[TMP9:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_15]], align 8
// CHECK11-NEXT:    [[TMP10:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_12]], align 8
// CHECK11-NEXT:    [[SUB_PTR_LHS_CAST19:%.*]] = ptrtoint ptr [[TMP9]] to i64
// CHECK11-NEXT:    [[SUB_PTR_RHS_CAST20:%.*]] = ptrtoint ptr [[TMP10]] to i64
// CHECK11-NEXT:    [[SUB_PTR_SUB21:%.*]] = sub i64 [[SUB_PTR_LHS_CAST19]], [[SUB_PTR_RHS_CAST20]]
// CHECK11-NEXT:    [[SUB_PTR_DIV22:%.*]] = sdiv exact i64 [[SUB_PTR_SUB21]], 4
// CHECK11-NEXT:    [[SUB23:%.*]] = sub nsw i64 [[SUB_PTR_DIV22]], 1
// CHECK11-NEXT:    [[ADD24:%.*]] = add nsw i64 [[SUB23]], 1
// CHECK11-NEXT:    [[DIV25:%.*]] = sdiv i64 [[ADD24]], 1
// CHECK11-NEXT:    [[MUL:%.*]] = mul nsw i64 [[DIV]], [[DIV25]]
// CHECK11-NEXT:    [[SUB26:%.*]] = sub nsw i64 [[MUL]], 1
// CHECK11-NEXT:    store i64 [[SUB26]], ptr [[DOTCAPTURE_EXPR_17]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON27:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON27]], ptr [[__BEGIN1]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON28:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON28]], ptr [[__BEGIN2]], align 8
// CHECK11-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_]], align 8
// CHECK11-NEXT:    store ptr [[TMP11]], ptr [[__BEGIN1]], align 8
// CHECK11-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_12]], align 8
// CHECK11-NEXT:    store ptr [[TMP12]], ptr [[__BEGIN2]], align 8
// CHECK11-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_]], align 8
// CHECK11-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_10]], align 8
// CHECK11-NEXT:    [[CMP:%.*]] = icmp ult ptr [[TMP13]], [[TMP14]]
// CHECK11-NEXT:    br i1 [[CMP]], label [[LAND_LHS_TRUE:%.*]], label [[OMP_PRECOND_END:%.*]]
// CHECK11:       land.lhs.true:
// CHECK11-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_12]], align 8
// CHECK11-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_15]], align 8
// CHECK11-NEXT:    [[CMP29:%.*]] = icmp ult ptr [[TMP15]], [[TMP16]]
// CHECK11-NEXT:    br i1 [[CMP29]], label [[OMP_PRECOND_THEN:%.*]], label [[OMP_PRECOND_END]]
// CHECK11:       omp.precond.then:
// CHECK11-NEXT:    [[FREEZE_POISON30:%.*]] = freeze i64 poison
// CHECK11-NEXT:    store i64 [[FREEZE_POISON30]], ptr [[DOTOMP_LB]], align 8
// CHECK11-NEXT:    store i64 0, ptr [[DOTOMP_LB]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON31:%.*]] = freeze i64 poison
// CHECK11-NEXT:    store i64 [[FREEZE_POISON31]], ptr [[DOTOMP_UB]], align 8
// CHECK11-NEXT:    [[TMP17:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_17]], align 8
// CHECK11-NEXT:    store i64 [[TMP17]], ptr [[DOTOMP_UB]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON32:%.*]] = freeze i64 poison
// CHECK11-NEXT:    store i64 [[FREEZE_POISON32]], ptr [[DOTOMP_STRIDE]], align 8
// CHECK11-NEXT:    store i64 1, ptr [[DOTOMP_STRIDE]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON33:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON33]], ptr [[DOTOMP_IS_LAST]], align 4
// CHECK11-NEXT:    store i32 0, ptr [[DOTOMP_IS_LAST]], align 4
// CHECK11-NEXT:    [[FREEZE_POISON35:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON35]], ptr [[__BEGIN134]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON37:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON37]], ptr [[__BEGIN236]], align 8
// CHECK11-NEXT:    [[TMP18:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK11-NEXT:    [[TMP19:%.*]] = load i32, ptr [[TMP18]], align 4, !freeze_bits [[META3]]
// CHECK11-NEXT:    call void @__kmpc_for_static_init_8(ptr @[[GLOB1]], i32 [[TMP19]], i32 34, ptr [[DOTOMP_IS_LAST]], ptr [[DOTOMP_LB]], ptr [[DOTOMP_UB]], ptr [[DOTOMP_STRIDE]], i64 1, i64 1)
// CHECK11-NEXT:    [[TMP20:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK11-NEXT:    [[TMP21:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_17]], align 8
// CHECK11-NEXT:    [[CMP38:%.*]] = icmp sgt i64 [[TMP20]], [[TMP21]]
// CHECK11-NEXT:    br i1 [[CMP38]], label [[COND_TRUE:%.*]], label [[COND_FALSE:%.*]]
// CHECK11:       cond.true:
// CHECK11-NEXT:    [[TMP22:%.*]] = load i64, ptr [[DOTCAPTURE_EXPR_17]], align 8
// CHECK11-NEXT:    br label [[COND_END:%.*]]
// CHECK11:       cond.false:
// CHECK11-NEXT:    [[TMP23:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK11-NEXT:    br label [[COND_END]]
// CHECK11:       cond.end:
// CHECK11-NEXT:    [[COND:%.*]] = phi i64 [ [[TMP22]], [[COND_TRUE]] ], [ [[TMP23]], [[COND_FALSE]] ]
// CHECK11-NEXT:    store i64 [[COND]], ptr [[DOTOMP_UB]], align 8
// CHECK11-NEXT:    [[TMP24:%.*]] = load i64, ptr [[DOTOMP_LB]], align 8
// CHECK11-NEXT:    store i64 [[TMP24]], ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    br label [[OMP_INNER_FOR_COND:%.*]]
// CHECK11:       omp.inner.for.cond:
// CHECK11-NEXT:    [[TMP25:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    [[TMP26:%.*]] = load i64, ptr [[DOTOMP_UB]], align 8
// CHECK11-NEXT:    [[CMP39:%.*]] = icmp sle i64 [[TMP25]], [[TMP26]]
// CHECK11-NEXT:    br i1 [[CMP39]], label [[OMP_INNER_FOR_BODY:%.*]], label [[OMP_INNER_FOR_END:%.*]]
// CHECK11:       omp.inner.for.body:
// CHECK11-NEXT:    [[TMP27:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_]], align 8
// CHECK11-NEXT:    [[TMP28:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    [[TMP29:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_15]], align 8
// CHECK11-NEXT:    [[TMP30:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_12]], align 8
// CHECK11-NEXT:    [[SUB_PTR_LHS_CAST40:%.*]] = ptrtoint ptr [[TMP29]] to i64
// CHECK11-NEXT:    [[SUB_PTR_RHS_CAST41:%.*]] = ptrtoint ptr [[TMP30]] to i64
// CHECK11-NEXT:    [[SUB_PTR_SUB42:%.*]] = sub i64 [[SUB_PTR_LHS_CAST40]], [[SUB_PTR_RHS_CAST41]]
// CHECK11-NEXT:    [[SUB_PTR_DIV43:%.*]] = sdiv exact i64 [[SUB_PTR_SUB42]], 4
// CHECK11-NEXT:    [[SUB44:%.*]] = sub nsw i64 [[SUB_PTR_DIV43]], 1
// CHECK11-NEXT:    [[ADD45:%.*]] = add nsw i64 [[SUB44]], 1
// CHECK11-NEXT:    [[DIV46:%.*]] = sdiv i64 [[ADD45]], 1
// CHECK11-NEXT:    [[MUL47:%.*]] = mul nsw i64 1, [[DIV46]]
// CHECK11-NEXT:    [[DIV48:%.*]] = sdiv i64 [[TMP28]], [[MUL47]]
// CHECK11-NEXT:    [[MUL49:%.*]] = mul nsw i64 [[DIV48]], 1
// CHECK11-NEXT:    [[ADD_PTR50:%.*]] = getelementptr inbounds i32, ptr [[TMP27]], i64 [[MUL49]]
// CHECK11-NEXT:    store ptr [[ADD_PTR50]], ptr [[__BEGIN134]], align 8
// CHECK11-NEXT:    [[TMP31:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_12]], align 8
// CHECK11-NEXT:    [[TMP32:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    [[TMP33:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    [[TMP34:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_15]], align 8
// CHECK11-NEXT:    [[TMP35:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_12]], align 8
// CHECK11-NEXT:    [[SUB_PTR_LHS_CAST51:%.*]] = ptrtoint ptr [[TMP34]] to i64
// CHECK11-NEXT:    [[SUB_PTR_RHS_CAST52:%.*]] = ptrtoint ptr [[TMP35]] to i64
// CHECK11-NEXT:    [[SUB_PTR_SUB53:%.*]] = sub i64 [[SUB_PTR_LHS_CAST51]], [[SUB_PTR_RHS_CAST52]]
// CHECK11-NEXT:    [[SUB_PTR_DIV54:%.*]] = sdiv exact i64 [[SUB_PTR_SUB53]], 4
// CHECK11-NEXT:    [[SUB55:%.*]] = sub nsw i64 [[SUB_PTR_DIV54]], 1
// CHECK11-NEXT:    [[ADD56:%.*]] = add nsw i64 [[SUB55]], 1
// CHECK11-NEXT:    [[DIV57:%.*]] = sdiv i64 [[ADD56]], 1
// CHECK11-NEXT:    [[MUL58:%.*]] = mul nsw i64 1, [[DIV57]]
// CHECK11-NEXT:    [[DIV59:%.*]] = sdiv i64 [[TMP33]], [[MUL58]]
// CHECK11-NEXT:    [[TMP36:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_15]], align 8
// CHECK11-NEXT:    [[TMP37:%.*]] = load ptr, ptr [[DOTCAPTURE_EXPR_12]], align 8
// CHECK11-NEXT:    [[SUB_PTR_LHS_CAST60:%.*]] = ptrtoint ptr [[TMP36]] to i64
// CHECK11-NEXT:    [[SUB_PTR_RHS_CAST61:%.*]] = ptrtoint ptr [[TMP37]] to i64
// CHECK11-NEXT:    [[SUB_PTR_SUB62:%.*]] = sub i64 [[SUB_PTR_LHS_CAST60]], [[SUB_PTR_RHS_CAST61]]
// CHECK11-NEXT:    [[SUB_PTR_DIV63:%.*]] = sdiv exact i64 [[SUB_PTR_SUB62]], 4
// CHECK11-NEXT:    [[SUB64:%.*]] = sub nsw i64 [[SUB_PTR_DIV63]], 1
// CHECK11-NEXT:    [[ADD65:%.*]] = add nsw i64 [[SUB64]], 1
// CHECK11-NEXT:    [[DIV66:%.*]] = sdiv i64 [[ADD65]], 1
// CHECK11-NEXT:    [[MUL67:%.*]] = mul nsw i64 1, [[DIV66]]
// CHECK11-NEXT:    [[MUL68:%.*]] = mul nsw i64 [[DIV59]], [[MUL67]]
// CHECK11-NEXT:    [[SUB69:%.*]] = sub nsw i64 [[TMP32]], [[MUL68]]
// CHECK11-NEXT:    [[MUL70:%.*]] = mul nsw i64 [[SUB69]], 1
// CHECK11-NEXT:    [[ADD_PTR71:%.*]] = getelementptr inbounds i32, ptr [[TMP31]], i64 [[MUL70]]
// CHECK11-NEXT:    store ptr [[ADD_PTR71]], ptr [[__BEGIN236]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON72:%.*]] = freeze ptr poison
// CHECK11-NEXT:    store ptr [[FREEZE_POISON72]], ptr [[A]], align 8
// CHECK11-NEXT:    [[TMP38:%.*]] = load ptr, ptr [[__BEGIN134]], align 8
// CHECK11-NEXT:    store ptr [[TMP38]], ptr [[A]], align 8
// CHECK11-NEXT:    [[FREEZE_POISON73:%.*]] = freeze i32 poison
// CHECK11-NEXT:    store i32 [[FREEZE_POISON73]], ptr [[B]], align 4
// CHECK11-NEXT:    [[TMP39:%.*]] = load ptr, ptr [[__BEGIN236]], align 8
// CHECK11-NEXT:    [[TMP40:%.*]] = load i32, ptr [[TMP39]], align 4, !freeze_bits [[META3]]
// CHECK11-NEXT:    store i32 [[TMP40]], ptr [[B]], align 4
// CHECK11-NEXT:    [[TMP41:%.*]] = load i32, ptr [[B]], align 4
// CHECK11-NEXT:    [[TMP42:%.*]] = load ptr, ptr [[A]], align 8, !nonnull [[META3]], !align [[META4]]
// CHECK11-NEXT:    store i32 [[TMP41]], ptr [[TMP42]], align 4
// CHECK11-NEXT:    br label [[OMP_BODY_CONTINUE:%.*]]
// CHECK11:       omp.body.continue:
// CHECK11-NEXT:    br label [[OMP_INNER_FOR_INC:%.*]]
// CHECK11:       omp.inner.for.inc:
// CHECK11-NEXT:    [[TMP43:%.*]] = load i64, ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    [[ADD74:%.*]] = add nsw i64 [[TMP43]], 1
// CHECK11-NEXT:    store i64 [[ADD74]], ptr [[DOTOMP_IV]], align 8
// CHECK11-NEXT:    br label [[OMP_INNER_FOR_COND]]
// CHECK11:       omp.inner.for.end:
// CHECK11-NEXT:    br label [[OMP_LOOP_EXIT:%.*]]
// CHECK11:       omp.loop.exit:
// CHECK11-NEXT:    [[TMP44:%.*]] = load ptr, ptr [[DOTGLOBAL_TID__ADDR]], align 8
// CHECK11-NEXT:    [[TMP45:%.*]] = load i32, ptr [[TMP44]], align 4, !freeze_bits [[META3]]
// CHECK11-NEXT:    call void @__kmpc_for_static_fini(ptr @[[GLOB1]], i32 [[TMP45]])
// CHECK11-NEXT:    br label [[OMP_PRECOND_END]]
// CHECK11:       omp.precond.end:
// CHECK11-NEXT:    ret void
//
