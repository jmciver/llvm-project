; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=module-inline -S < %s | FileCheck %s --check-prefix=CHECK
;
; Verify module inlining occurs when both caller and callee have a
; fine_grained_bitfields attribute.

define void @modify_value({i32, float}* %v) fine_grained_bitfields {
; CHECK-LABEL: @modify_value(
; CHECK-NEXT:    [[F:%.*]] = getelementptr { i32, float }, { i32, float }* [[V:%.*]], i64 0, i32 0
; CHECK-NEXT:    store i32 10, i32* [[F]], align 4
; CHECK-NEXT:    ret void
;
  %f = getelementptr { i32, float }, { i32, float }* %v, i64 0, i32 0
  store i32 10, i32* %f
  ret void
}

define i32 @main() fine_grained_bitfields {
; CHECK-LABEL: @main(
; CHECK-NEXT:    [[MY_VAL:%.*]] = alloca { i32, float }, align 8
; CHECK-NEXT:    [[F_I:%.*]] = getelementptr { i32, float }, { i32, float }* [[MY_VAL]], i64 0, i32 0
; CHECK-NEXT:    store i32 10, i32* [[F_I]], align 4
; CHECK-NEXT:    [[F:%.*]] = getelementptr { i32, float }, { i32, float }* [[MY_VAL]], i64 0, i32 0
; CHECK-NEXT:    [[RET:%.*]] = load i32, i32* [[F]], align 4
; CHECK-NEXT:    ret i32 [[RET]]
;
  %my_val = alloca {i32, float}
  call void @modify_value({i32, float}* %my_val)
  %f = getelementptr { i32, float }, { i32, float }* %my_val, i64 0, i32 0
  %ret = load i32, i32* %f
  ret i32 %ret
}
